"\npub!mod!concave_component;\npub!mod!convex_component;\npub!mod!convexity;\npub!mod!line_segment;struct!LineSegmentStroke{points:Leash<CyclicSlice<Point2d>>, start:Point2d, end:Point2d}struct!LineSegmentSketch{contour:Leash<RawContour>, strokes:Vec<LineSegmentStroke>}pub!fn!go_right{\n    let!L=u.x*u.x+u.y*u.y.sqrt();assert!(L>r)\n    let!dr=r*L/L*L-r*r.sqrt();\n    let!dx=dr*u.y/L;\n    let!dy=-dr*u.x/L;\n    Vector2d(u.x+dx, u.y+dy);\n}\npub!fn!go_left{\n    let!L=u.x*u.x+u.y*u.y.sqrt();assert!(L>r)\n    let!dr=r*L/L*L-r*r.sqrt();\n    let!dx=-dr*u.y/L;\n    let!dy=dr*u.x/L;\n    Vector2d(u.x+dx, u.y+dy);\n}\npub!fn!extend_end{\n    let!end=start;\n    let!dp=ct.displacement(start, end+1);\n    let!N=ct.points.ilen();\n    let!max_end=start+N;while!end<=max_end&&dp.norm()<r{\n        end+= 1;\n        dp=ct.displacement(start, end+1);\n    }\n    if!dp.norm()<r{return!(end)\n    }\n;\n    let!right_bound=go_right(dp, r);\n    let!left_bound=go_left(dp, r);\n    let!r_max=0;while!end<=max_end&&right_bound.rotation_direction_to(dp)>=0&&dp.rotation_direction_to(left_bound)>=0{\n        let!dp_norm=dp.norm();        if!dp_norm<r_max-r{\n            break!;\n        }\nelse!if!dp_norm>r_max{\n            r_max=dp_norm;\n        }\n;        if!dp_norm>r{\n            let!dp_right=go_right(dp, r);\n            let!dp_left=go_left(dp, r);            if!right_bound.rotation_direction_to(dp_right)>0{\n                right_bound=dp_right;\n            }\n;            if!dp_left.rotation_direction_to(left_bound)>0{\n                left_bound=dp_left;\n            }\n;\n        }\n;\n        end+= 1;\n        dp=ct.displacement(start, end+1);\n    }\nassert!(end>start)return!(end)\n}\npub!fn!extend_start{\n    let!start=end;\n    let!dp0=ct.displacement(end, start-1);\n    let!min_start=end-ct.points.ilen();while!start>=min_start&&dp0.norm()<r{\n        start-= 1;\n        dp0=ct.displacement(end, start-1);\n    }\n    if!dp0.norm()<r{return!(start.min(start0))\n    }\n;\n    let!right_bound=go_right(dp0, r);\n    let!left_bound=go_left(dp0, r);\n    let!r_max=0;while!start>=min_start{\n        let!dp=ct.displacement(end, start-1);\n        let!dp_norm=dp.norm();        if!dp_norm<r_max-r{\n            break!;\n        }\nelse!if!dp_norm>r_max{\n            r_max=dp_norm;\n        }\n;        if!dp_norm>r{\n            let!dp_right=go_right(dp, r);\n            let!dp_left=go_left(dp, r);            if!right_bound.rotation_direction_to(dp_right)>0{\n                right_bound=dp_right;\n            }\n;            if!dp_left.rotation_direction_to(left_bound)>0{\n                left_bound=dp_left;\n            }\n;\n        }\n;        if!right_bound.rotation_direction_to(left_bound)>=0{            if!start<=start0&&!right_bound.rotation_direction_to(dp)>=0&&dp.rotation_direction_to(left_bound)>=0{\n                break!;\n            }\n;\n            start-= 1;\n        }\nelse!{\n            break!;\n        }\n;\n    }\n    if!start<=start0{return!(start)\n    }\nelse!{return!(start0)\n    }\n;\n}\npub!fn!find_line_segments{\n    let!line_segments:Vec<LineSegmentStroke>=vec![];\n    let!start=0;\n    let!end=1;\n    let!max_end=ct.points.ilen();while!end<=max_end{\n        end=extend_end(ct, start, r);\n        let!ls_extend_end=new(ct, start, end);\n        let!extend_start_flag=true;        if!line_segments.ilen()>0{\n            let!dp_extend_end=ls_extend_end.displacement();\n            let!dp_previous=line_segments.last().unwrap().displacement();            if!dp_extend_end.cross(dp_previous).abs()<0.01&&dp_extend_end.dot(dp_previous)>0{\n                let!N=ct.points.ilen();\n                line_segments.last().unwrap()=new(ct, line_segments.last().unwrap().points.start(), end);\n                extend_start_flag=false;\n            }\n;\n        }\n;        if!extend_start_flag{\n            start=extend_start(ct, start, end, r);\n            let!ls=new(ct, start, end);            if!line_segments.ilen()>0{\n                let!ls_last=line_segments.last().unwrap();\n                let!dp_last=ls_last.displacement();\n                let!dp=ls.displacement();\n                let!dp1=ls_last.start.to(ls.end);                if!dp.cross(dp_last).abs()<0.001&&dp.dot(dp_last)>0&&dp.cross(dp1).abs()<0.001&&dp.dot(dp1)>0{\n                    let!ls_last=line_segments.pop().unwrap();\n                    ls=new(ct, ls_last.points.start(), ls.points.end());\n                }\n;\n            }\nelse!{\n                max_end=start+ct.points.ilen();\n            }\n;\n            line_segments.push(ls);\n        }\n;\n        start=end;\n        end=start+1;\n    }\n    let!N=ct.points.ilen();\n    let!first_line_segment_points_end=line_segments.first().unwrap().points.end();\n    let!last_line_segment=line_segments.last().unwrap();    if!last_line_segment.points.end()>=first_line_segment_points_end+N{\n        let!last_line_segment=line_segments.pop().unwrap();\n        line_segments.first().unwrap()=new(ct, last_line_segment.points.start()-N, line_segments.first().unwrap().points.end()-1);\n    }\n;\n    line_segments;\n}\nimpl!fn!visualize(){\n    ;\n}\nimpl!fn!new(, , ){assert!(from<=to)\n    LineSegmentStroke(ct.points.cyclic_slice_leashed(from, to+1));\n}\nfn!displacement(){\n    Self.start.to(Self.end);\n}\nimpl!fn!visualize(){\n    Self.strokes.visualize();\n}\nimpl!fn!concave_components(self){\n    find_concave_components(Self);\n}\nfn!bounding_box(self){\n    let!start_point=Self.strokes[0].start;\n    let!xmin=start_point.x;\n    let!xmax=start_point.x;\n    let!ymin=start_point.y;\n    let!ymax=start_point.y;for!{\n        let!point=Self.strokes[i].end;\n        xmin=xmin.min(point.x);\n        xmax=xmax.max(point.x);\n        ymin=ymin.min(point.y);\n        ymax=ymax.max(point.y);\n    }\nreturn!(BoundingBox(ClosedRange(xmin, xmax), ClosedRange(ymin, ymax)))\n}\nfn!new(, ){\n    LineSegmentSketch(ct, find_line_segments(ct, r));\n}\n"