"struct!RawContour{cc:Leash<ConnectedComponent>, points:Vec<Point2d>}struct!Directionpub!fn!get_pixel_pair{\n    row>>j-1|3;\n}\npub!fn!get_pixel_to_the_left{\n    row>>j|1;\n}\npub!fn!get_pixel_to_the_right{\n    row>>j-1|1;\n}\npub!fn!get_inward_direction{\n    let!pixel_pair_above=get_pixel_pair(row_above, j);\n    let!pixel_pair_below=get_pixel_pair(row_below, j);match!\n}\npub!fn!get_angle_change{\n    let!raw_angle_change=outwardasi32-inwardasi32asr32.last_bits(2);match!\n}\npub!fn!get_outward_direction{\n    let!pixel_pair_above=get_pixel_pair(row_above, j);\n    let!pixel_pair_below=get_pixel_pair(row_below, j);match!\n}\nstruct!StreakCache{prev1:i32, prev2:i32}pub!fn!get_concave_middle_point{\n    let!N=points.ilen();\n    let!p0=points[N-2];\n    let!p2=points[N-1];\n    Point2d(p0.x+p2.x/2, p0.y+p2.y/2);\n}\npub!fn!find_raw_contours{\n    let!result:Vec<RawContour>=vec![];\n    let!boundary_unsearched=new_zeros();for!{\n        let!r_ur=cc.mask[i-1];\n        let!r_dr=cc.mask[i];\n        let!r_ul=r_ur<<1;\n        let!r_dl=r_dr<<1;\n        boundary_unsearched[i]=r_ur|r_dr|r_ul|r_dl|!r_ur|r_dr|r_ul|r_dl;\n    }\nfor!{while!boundary_unsearched[k]{\n            let!contour:Vec<Point2d>=vec![];\n            let!i=k;\n            let!j=boundary_unsearched[k].ctz();\n            let!row_above=cc.mask[i-1];\n            let!row_below=cc.mask[i];\n            let!inward_direction=get_inward_direction(row_above, row_below, j);\n            let!i0=i;\n            let!j0=j;\n            let!dir0=inward_direction;\n            let!prev_angle_change1=0;\n            let!prev_angle_change2=0;\n            let!total_angle_change=0;\n            let!prev_streak1=-1;\n            let!prev_streak2=-1;\n            let!current_streak=-1;while!true            if!prev_angle_change1==-1&&current_streak==1&&prev_streak1>0{\n                contour.pop();\n            }\n;\n            result.push(RawContour(cc, contour));\n        }\n    }\nreturn!(result)\n}\nimpl!fn!visualize(){\n    ;\n}\nimpl!fn!line_segment_sketch(self){\n    new(Self, 1.4);\n}\nfn!bounding_box(self){\n    let!start_point=Self.points[0];\n    let!xmin=start_point.x;\n    let!xmax=start_point.x;\n    let!ymin=start_point.y;\n    let!ymax=start_point.y;for!{\n        let!point=Self.points[i];\n        xmin=xmin.min(point.x);\n        xmax=xmax.max(point.x);\n        ymin=ymin.min(point.y);\n        ymax=ymax.max(point.y);\n    }\nreturn!(BoundingBox(ClosedRange(xmin, xmax), ClosedRange(ymin, ymax)))\n}\nfn!relative_bounding_box(self){\n    Self.cc.raw_contours[0].bounding_box.relative_bounding_box(Self.bounding_box);\n}\nfn!contour_len(self){\n    let!contour_len=0;for!{\n        let!a=Self.points[i-1];\n        let!b=Self.points[i];\n        contour_len+=a.x-b.x.abs()+a.y-b.y.abs();\n    }\n    let!a=Self.points[Self.points.ilen()-1];\n    let!b=Self.points[0];\n    contour_len+=a.x-b.x.abs()+a.y-b.y.abs();return!(contour_len)\n}\nfn!displacement(, , ){\n    let!N=Self.points.ilen();\n    let!ct_start=Self.points[start%N];\n    let!ct_end=Self.points[end%N];\n    ct_start.to(ct_end);\n}\n"