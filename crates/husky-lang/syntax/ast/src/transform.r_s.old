use atom::{AtomKind, AtomicLineGroup, AtomicText};
use fold::{FoldIdx, FoldedList};
use text::TextRanged;

use crate::{expr::ExprStack, *};

pub type AstResult<Ast> = AstResult<Ast>;

pub(crate) struct AtomToAstTransformer {
    arena: ExprArena,
    fold_results: FoldedList<AstResult<Ast>>,
}

#[derive(Debug, Clone, PartialEq, Eq)]
pub struct AstText {
    pub arena: ExprArena,
    pub fold_results: FoldedList<AstResult<Ast>>,
}

impl AstText {
    pub fn errors(&self) -> Vec<&AstError> {
        self.fold_results
            .nodes
            .iter()
            .filter_map(|node| node.value.as_ref().err())
            .collect()
    }
}

impl AtomToAstTransformer {
    pub(crate) fn new() -> Self {
        Self {
            arena: ExprArena::new(),
            fold_results: FoldedList::new(),
        }
    }

    pub(crate) fn finish(self) -> AstText {
        AstText {
            arena: self.arena,
            fold_results: self.fold_results,
        }
    }
}

pub struct AstTask {}

impl fold::Transformer<AstResult<Ast>, AtomicText, AstResult<Ast>, AstTask>
    for AtomToAstTransformer
{
    fn _enter_block(&mut self) {}

    fn _exit(&mut self) {}

    fn transform(
        &mut self,
        _: fold::Indent,
        atom_result: &atom::AstResult<Ast>,
        enter_block: &mut impl FnOnce(&mut Self),
    ) -> AstResult<Ast> {
        match atom_result.clone()? {
            Ast::Stmt(stmt) => {
                let expr = if stmt.atoms.len() == 0 {
                    None
                } else {
                    let mut atom_iter = stmt.atoms.iter().peekable();
                    let mut stack = ExprStack::new(&mut self.arena);
                    while let Some(atom) = atom_iter.next() {
                        match &atom.kind {
                            AtomKind::Variable(_)
                            | AtomKind::Literal(_)
                            | AtomKind::Scope(_, _) => stack.accept_atom_expr(atom.into()),
                            AtomKind::Binary(opr) => stack.accept_binary(*opr),
                            AtomKind::Prefix(prefix) => {
                                stack.accept_prefix(*prefix, atom.text_end())
                            }
                            AtomKind::Suffix(suffix) => {
                                stack.accept_suffix(*suffix, atom.text_end())
                            }
                            AtomKind::ListStart(bra, attr) => {
                                stack.accept_list_start(*bra, *attr, atom.text_start())
                            }
                            AtomKind::ListEnd(ket, attr) => {
                                stack.accept_list_end(*ket, *attr, atom.text_end())?
                            }
                            AtomKind::ListItem => stack.accept_list_item(),
                            AtomKind::LambdaHead(args) => {
                                stack.accept_lambda_head(args.clone(), atom.text_start())
                            }
                        }
                    }
                    Some(stack.finish())
                };
                Stmt::parse(&self.arena, &stmt.attr, expr)
            }
            Ast::TypeDef { ident, kind, args } => Ok(Ast::TypeDef {
                ident,
                kind,
                generics: args,
            }),
            Ast::MainDef => Ok(Ast::MainDef),
            Ast::FuncDef { kind, decl } => Ok(Ast::FuncDef { kind, decl }),
            Ast::Use { ident, scope } => Ok(Ast::Use { ident, scope }),
            Ast::MembDef { ident, kind } => Ok(Ast::MembDef { ident, kind }),
            Ast::DatasetConfig => Ok(Ast::DatasetConfig),
        }
    }

    fn folded_output_mut(&mut self) -> &mut FoldedList<AstResult<Ast>> {
        &mut self.fold_results
    }
}
