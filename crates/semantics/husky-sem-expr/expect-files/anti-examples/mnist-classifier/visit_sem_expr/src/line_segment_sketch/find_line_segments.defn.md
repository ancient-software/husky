```rust
Some(
    [
        "[]",
        "let mut line_segments: []LineSegmentStroke = []",
        "0",
        "let mut start = 0",
        "1",
        "let mut end = 1",
        "ct",
        "ct.points",
        "ct.points.ilen()",
        "let mut max_end = ct.points.ilen()",
        "end",
        "max_end",
        "end <= max_end",
        "end <= max_end",
        "end",
        "extend_end",
        "ct",
        "start",
        "r",
        "extend_end(ct, start, r)",
        "end = extend_end(ct, start, r)",
        "end = extend_end(ct, start, r)",
        "LineSegmentStroke::new",
        "ct",
        "start",
        "end",
        "LineSegmentStroke::new(ct, start, end)",
        "let ls_extend_end = LineSegmentStroke::new(ct, start, end)",
        "true",
        "let mut extend_start_flag = true",
        "line_segments",
        "line_segments.ilen()",
        "0",
        "line_segments.ilen() > 0",
        "line_segments.ilen() > 0",
        "ls_extend_end",
        "ls_extend_end.displacement()",
        "let dp_extend_end = ls_extend_end.displacement()",
        "line_segments",
        "line_segments.last()",
        "line_segments.last()!",
        "line_segments.last()!.displacement()",
        "let dp_previous = line_segments.last()!.displacement()",
        "dp_extend_end",
        "dp_previous",
        "dp_extend_end.cross(dp_previous)",
        "dp_extend_end.cross(dp_previous).abs()",
        "0.01",
        "dp_extend_end.cross(dp_previous).abs() < 0.01",
        "dp_extend_end",
        "dp_previous",
        "dp_extend_end.dot(dp_previous)",
        "0.0",
        "dp_extend_end.dot(dp_previous) > 0.0",
        "dp_extend_end.cross(dp_previous).abs() < 0.01 \n                    and dp_extend_end.dot(dp_previous) > 0.0",
        "dp_extend_end.cross(dp_previous).abs() < 0.01 \n                    and dp_extend_end.dot(dp_previous) > 0.0",
        "ct",
        "ct.points",
        "ct.points.ilen()",
        "let N = ct.points.ilen()",
        "line_segments",
        "line_segments.last()",
        "line_segments.last()!",
        "LineSegmentStroke::new",
        "ct",
        "line_segments",
        "line_segments.last()",
        "line_segments.last()!",
        "line_segments.last()!.points",
        "line_segments.last()!.points.start()",
        "end",
        "LineSegmentStroke::new(ct, line_segments.last()!.points.start(), end)",
        "line_segments.last()! = LineSegmentStroke::new(ct, line_segments.last()!.points.start(), end)",
        "line_segments.last()! = LineSegmentStroke::new(ct, line_segments.last()!.points.start(), end)",
        "extend_start_flag",
        "false",
        "extend_start_flag = false",
        "extend_start_flag = false",
        "if dp_extend_end.cross(dp_previous).abs() < 0.01 \n                    and dp_extend_end.dot(dp_previous) > 0.0:\n                let N = ct.points.ilen()\n                line_segments.last()! = LineSegmentStroke::new(ct, line_segments.last()!.points.start(), end)\n                extend_start_flag = false",
        "if line_segments.ilen() > 0:\n            let dp_extend_end = ls_extend_end.displacement()\n            let dp_previous = line_segments.last()!.displacement()\n            if dp_extend_end.cross(dp_previous).abs() < 0.01 \n                    and dp_extend_end.dot(dp_previous) > 0.0:\n                let N = ct.points.ilen()\n                line_segments.last()! = LineSegmentStroke::new(ct, line_segments.last()!.points.start(), end)\n                extend_start_flag = false",
        "extend_start_flag",
        "extend_start_flag",
        "start",
        "extend_start",
        "ct",
        "start",
        "end",
        "r",
        "extend_start(ct, start, end, r)",
        "start = extend_start(ct, start, end, r)",
        "start = extend_start(ct, start, end, r)",
        "LineSegmentStroke::new",
        "ct",
        "start",
        "end",
        "LineSegmentStroke::new(ct, start, end)",
        "let mut ls = LineSegmentStroke::new(ct, start, end)",
        "line_segments",
        "line_segments.ilen()",
        "0",
        "line_segments.ilen() > 0",
        "line_segments.ilen() > 0",
        "line_segments",
        "line_segments.last()",
        "line_segments.last()!",
        "let ls_last = line_segments.last()!",
        "ls_last",
        "ls_last.displacement()",
        "let dp_last = ls_last.displacement()",
        "ls",
        "ls.displacement()",
        "let dp = ls.displacement()",
        "ls_last",
        "ls_last.start",
        "ls",
        "ls.end",
        "ls_last.start.to(ls.end)",
        "let dp1 = ls_last.start.to(ls.end)",
        "dp",
        "dp_last",
        "dp.cross(dp_last)",
        "dp.cross(dp_last).abs()",
        "0.001",
        "dp.cross(dp_last).abs() < 0.001",
        "dp",
        "dp_last",
        "dp.dot(dp_last)",
        "0.0",
        "dp.dot(dp_last) > 0.0",
        "dp.cross(dp_last).abs() < 0.001 \n                        and dp.dot(dp_last) > 0.0",
        "dp",
        "dp1",
        "dp.cross(dp1)",
        "dp.cross(dp1).abs()",
        "0.001",
        "dp.cross(dp1).abs()<0.001",
        "dp.cross(dp_last).abs() < 0.001 \n                        and dp.dot(dp_last) > 0.0 \n                        and dp.cross(dp1).abs()<0.001",
        "dp",
        "dp1",
        "dp.dot(dp1)",
        "0.0",
        "dp.dot(dp1) > 0.0",
        "dp.cross(dp_last).abs() < 0.001 \n                        and dp.dot(dp_last) > 0.0 \n                        and dp.cross(dp1).abs()<0.001 \n                        and dp.dot(dp1) > 0.0",
        "dp.cross(dp_last).abs() < 0.001 \n                        and dp.dot(dp_last) > 0.0 \n                        and dp.cross(dp1).abs()<0.001 \n                        and dp.dot(dp1) > 0.0",
        "line_segments",
        "line_segments.pop()",
        "line_segments.pop()!",
        "let ls_last = line_segments.pop()!",
        "ls",
        "LineSegmentStroke::new",
        "ct",
        "ls_last",
        "ls_last.points",
        "ls_last.points.start()",
        "ls",
        "ls.points",
        "ls.points.end()",
        "LineSegmentStroke::new(ct, ls_last.points.start(), ls.points.end())",
        "ls = LineSegmentStroke::new(ct, ls_last.points.start(), ls.points.end())",
        "ls = LineSegmentStroke::new(ct, ls_last.points.start(), ls.points.end())",
        "if dp.cross(dp_last).abs() < 0.001 \n                        and dp.dot(dp_last) > 0.0 \n                        and dp.cross(dp1).abs()<0.001 \n                        and dp.dot(dp1) > 0.0:\n                    let ls_last = line_segments.pop()!\n                    ls = LineSegmentStroke::new(ct, ls_last.points.start(), ls.points.end())",
        "max_end",
        "start",
        "ct",
        "ct.points",
        "ct.points.ilen()",
        "start + ct.points.ilen()",
        "max_end = start + ct.points.ilen()",
        "max_end = start + ct.points.ilen()",
        "if line_segments.ilen() > 0:\n                let ls_last = line_segments.last()!\n                let dp_last = ls_last.displacement()\n                let dp = ls.displacement()\n                let dp1 = ls_last.start.to(ls.end)\n                if dp.cross(dp_last).abs() < 0.001 \n                        and dp.dot(dp_last) > 0.0 \n                        and dp.cross(dp1).abs()<0.001 \n                        and dp.dot(dp1) > 0.0:\n                    let ls_last = line_segments.pop()!\n                    ls = LineSegmentStroke::new(ct, ls_last.points.start(), ls.points.end())\n            else:\n                max_end = start + ct.points.ilen()",
        "line_segments",
        "ls",
        "line_segments.push(ls)",
        "line_segments.push(ls)",
        "if extend_start_flag:\n            start = extend_start(ct, start, end, r)\n            let mut ls = LineSegmentStroke::new(ct, start, end)\n            if line_segments.ilen() > 0:\n                let ls_last = line_segments.last()!\n                let dp_last = ls_last.displacement()\n                let dp = ls.displacement()\n                let dp1 = ls_last.start.to(ls.end)\n                if dp.cross(dp_last).abs() < 0.001 \n                        and dp.dot(dp_last) > 0.0 \n                        and dp.cross(dp1).abs()<0.001 \n                        and dp.dot(dp1) > 0.0:\n                    let ls_last = line_segments.pop()!\n                    ls = LineSegmentStroke::new(ct, ls_last.points.start(), ls.points.end())\n            else:\n                max_end = start + ct.points.ilen()\n            line_segments.push(ls)",
        "start",
        "end",
        "start = end",
        "start = end",
        "end",
        "start",
        "1",
        "start + 1",
        "end = start + 1",
        "end = start + 1",
        "while end <= max_end:\n        end = extend_end(ct, start, r)\n        let ls_extend_end = LineSegmentStroke::new(ct, start, end)\n        let mut extend_start_flag = true\n        if line_segments.ilen() > 0:\n            let dp_extend_end = ls_extend_end.displacement()\n            let dp_previous = line_segments.last()!.displacement()\n            if dp_extend_end.cross(dp_previous).abs() < 0.01 \n                    and dp_extend_end.dot(dp_previous) > 0.0:\n                let N = ct.points.ilen()\n                line_segments.last()! = LineSegmentStroke::new(ct, line_segments.last()!.points.start(), end)\n                extend_start_flag = false\n        if extend_start_flag:\n            start = extend_start(ct, start, end, r)\n            let mut ls = LineSegmentStroke::new(ct, start, end)\n            if line_segments.ilen() > 0:\n                let ls_last = line_segments.last()!\n                let dp_last = ls_last.displacement()\n                let dp = ls.displacement()\n                let dp1 = ls_last.start.to(ls.end)\n                if dp.cross(dp_last).abs() < 0.001 \n                        and dp.dot(dp_last) > 0.0 \n                        and dp.cross(dp1).abs()<0.001 \n                        and dp.dot(dp1) > 0.0:\n                    let ls_last = line_segments.pop()!\n                    ls = LineSegmentStroke::new(ct, ls_last.points.start(), ls.points.end())\n            else:\n                max_end = start + ct.points.ilen()\n            line_segments.push(ls)\n        start = end\n        end = start + 1",
        "ct",
        "ct.points",
        "ct.points.ilen()",
        "let N = ct.points.ilen()",
        "line_segments",
        "line_segments.first()",
        "line_segments.first()!",
        "line_segments.first()!.points",
        "line_segments.first()!.points.end()",
        "let first_line_segment_points_end = line_segments.first()!.points.end()",
        "line_segments",
        "line_segments.last()",
        "line_segments.last()!",
        "let last_line_segment = line_segments.last()!",
        "last_line_segment",
        "last_line_segment.points",
        "last_line_segment.points.end()",
        "first_line_segment_points_end",
        "N",
        "first_line_segment_points_end + N",
        "last_line_segment.points.end() >= first_line_segment_points_end + N",
        "last_line_segment.points.end() >= first_line_segment_points_end + N",
        "line_segments",
        "line_segments.pop()",
        "line_segments.pop()!",
        "let last_line_segment = line_segments.pop()!",
        "line_segments",
        "line_segments.first()",
        "line_segments.first()!",
        "LineSegmentStroke::new",
        "ct",
        "last_line_segment",
        "last_line_segment.points",
        "last_line_segment.points.start()",
        "N",
        "last_line_segment.points.start() - N",
        "line_segments",
        "line_segments.first()",
        "line_segments.first()!",
        "line_segments.first()!.points",
        "line_segments.first()!.points.end()",
        "1",
        "line_segments.first()!.points.end() - 1",
        "LineSegmentStroke::new(\n            ct,\n            last_line_segment.points.start() - N,\n            line_segments.first()!.points.end() - 1\n        )",
        "line_segments.first()! = LineSegmentStroke::new(\n            ct,\n            last_line_segment.points.start() - N,\n            line_segments.first()!.points.end() - 1\n        )",
        "line_segments.first()! = LineSegmentStroke::new(\n            ct,\n            last_line_segment.points.start() - N,\n            line_segments.first()!.points.end() - 1\n        )",
        "if last_line_segment.points.end() >= first_line_segment_points_end + N:\n        let last_line_segment = line_segments.pop()!\n        line_segments.first()! = LineSegmentStroke::new(\n            ct,\n            last_line_segment.points.start() - N,\n            line_segments.first()!.points.end() - 1\n        )",
        "line_segments",
        "line_segments",
        "let mut line_segments: []LineSegmentStroke = []\n    let mut start = 0\n    let mut end = 1\n    let mut max_end = ct.points.ilen()\n    while end <= max_end:\n        end = extend_end(ct, start, r)\n        let ls_extend_end = LineSegmentStroke::new(ct, start, end)\n        let mut extend_start_flag = true\n        if line_segments.ilen() > 0:\n            let dp_extend_end = ls_extend_end.displacement()\n            let dp_previous = line_segments.last()!.displacement()\n            if dp_extend_end.cross(dp_previous).abs() < 0.01 \n                    and dp_extend_end.dot(dp_previous) > 0.0:\n                let N = ct.points.ilen()\n                line_segments.last()! = LineSegmentStroke::new(ct, line_segments.last()!.points.start(), end)\n                extend_start_flag = false\n        if extend_start_flag:\n            start = extend_start(ct, start, end, r)\n            let mut ls = LineSegmentStroke::new(ct, start, end)\n            if line_segments.ilen() > 0:\n                let ls_last = line_segments.last()!\n                let dp_last = ls_last.displacement()\n                let dp = ls.displacement()\n                let dp1 = ls_last.start.to(ls.end)\n                if dp.cross(dp_last).abs() < 0.001 \n                        and dp.dot(dp_last) > 0.0 \n                        and dp.cross(dp1).abs()<0.001 \n                        and dp.dot(dp1) > 0.0:\n                    let ls_last = line_segments.pop()!\n                    ls = LineSegmentStroke::new(ct, ls_last.points.start(), ls.points.end())\n            else:\n                max_end = start + ct.points.ilen()\n            line_segments.push(ls)\n        start = end\n        end = start + 1\n    let N = ct.points.ilen()\n    let first_line_segment_points_end = line_segments.first()!.points.end()\n    let last_line_segment = line_segments.last()!\n    if last_line_segment.points.end() >= first_line_segment_points_end + N:\n        let last_line_segment = line_segments.pop()!\n        line_segments.first()! = LineSegmentStroke::new(\n            ct,\n            last_line_segment.points.start() - N,\n            line_segments.first()!.points.end() - 1\n        )\n    line_segments",
    ],
)
```