// this is generated by husky_vm_interface_code_gen::rust_code::write_rust_code
// do not modify by hand

use crate::*;

type void = ();
type r32 = u32;
type b64 = u64;

// void
#[rustfmt::skip]
#[no_mangle]
pub unsafe extern "C" fn __void_primitive_value_to_bool(data: __RegisterData) -> bool {
    let _data = data.as_void;
    false
}

#[rustfmt::skip]
#[no_mangle]
pub unsafe extern "C" fn __void_primitive_ref_to_bool(data_ptr: *mut std::ffi::c_void) -> bool {
    let _data = unsafe { *(data_ptr as *const void) };
    false
}

#[rustfmt::skip]
#[no_mangle]
pub unsafe extern "C" fn __void_primitive_value_to_box(data: __RegisterData) -> *mut std::ffi::c_void {
    let data = data.as_void;
    let ptr: *mut void = Box::<void>::into_raw(Box::new(data));
    ptr as *mut std::ffi::c_void
}

#[rustfmt::skip]
#[no_mangle]
pub unsafe extern "C" fn __void_clone(data: *mut c_void) -> *mut std::ffi::c_void {
    Box::<void>::into_raw(Box::new((*(data as *mut void)).clone())) as *mut std::ffi::c_void
}

#[rustfmt::skip]
#[no_mangle]
pub unsafe extern "C" fn __void_drop(data: *mut c_void) {
    drop(Box::from_raw(data as *mut void))
}

#[rustfmt::skip]
#[no_mangle]
pub unsafe extern "C" fn __void_eq(this: &std::ffi::c_void, other: &std::ffi::c_void) -> bool {
    *(this as *const std::ffi::c_void as *const void) == *(other as *const std::ffi::c_void as *const void)
}

#[rustfmt::skip]
#[no_mangle]
pub unsafe extern "C" fn __void_assign(registers: *mut __RegularValue) {
    let registers = std::slice::from_raw_parts_mut(registers, 2);
    *registers[0].downcast_temp_mut::<void>(&__VOID_VTABLE) = registers[1].downcast_void()
}

#[rustfmt::skip]
#[no_mangle]
pub static __VOID_VTABLE: __RegisterTyVTable = __RegisterTyVTable {
    primitive_value_to_bool: Some(__void_primitive_value_to_bool),
    primitive_ref_to_bool: Some(__void_primitive_ref_to_bool),
    primitive_value_to_box: Some(__void_primitive_value_to_box),
    clone: __void_clone,
    drop: __void_drop,
    eq: __void_eq,
    assign: __void_assign,
    typename_str: "void",
    typename_str_hash_u64: 8073556201194512886,
};

#[rustfmt::skip]
impl __RegularValue {
    pub fn downcast_void(&self) -> void {
        todo!()
        // unsafe {
        //     if self.vtable.typename_str_hash_u64 != 8073556201194512886 {
        //         panic!("expect `void` but get {} instead", self.vtable.typename_str)
        //     }
        //     match self.data_kind {
        //         __RegisterDataKind::PrimitiveValue => self.data.as_void,
        //         __RegisterDataKind::Leash
        //         | __RegisterDataKind::TempRef
        //         | __RegisterDataKind::TempMut
        //         | __RegisterDataKind::Box => *(self.data.as_ptr as *const void),
        //         _ => panic!(),
        //     }
        // }
    }

    pub fn downcast_opt_void(&self) -> Option<void> {
        todo!()
        // unsafe {
        //     if self.vtable.typename_str_hash_u64 != 8073556201194512886 {
        //         panic!("expect `void` but get `{}` instead", self.vtable.typename_str)
        //     }
        //     match self.data_kind {
        //         __RegisterDataKind::PrimitiveValue => Some(self.data.as_void),
        //         __RegisterDataKind::Leash
        //         | __RegisterDataKind::TempRef
        //         | __RegisterDataKind::TempMut
        //         | __RegisterDataKind::Box => Some(*(self.data.as_ptr as *const void)),
        //         __RegisterDataKind::SomeNone => {
        //             assert_eq!(unsafe {self.data.as_number_of_somes}, 0);
        //             None
        //         },
        //         _ => panic!(),
        //     }
        // }
    }
}

// bool
#[rustfmt::skip]
#[no_mangle]
pub unsafe extern "C" fn __bool_primitive_value_to_bool(data: __RegisterData) -> bool {
    let data = data.as_bool;
    data
}

#[rustfmt::skip]
#[no_mangle]
pub unsafe extern "C" fn __bool_primitive_ref_to_bool(data_ptr: *mut std::ffi::c_void) -> bool {
    let data = unsafe { *(data_ptr as *const bool) };
    data
}

#[rustfmt::skip]
#[no_mangle]
pub unsafe extern "C" fn __bool_primitive_value_to_box(data: __RegisterData) -> *mut std::ffi::c_void {
    let data = data.as_bool;
    let ptr: *mut bool = Box::<bool>::into_raw(Box::new(data));
    ptr as *mut std::ffi::c_void
}

#[rustfmt::skip]
#[no_mangle]
pub unsafe extern "C" fn __bool_clone(data: *mut c_void) -> *mut std::ffi::c_void {
    Box::<bool>::into_raw(Box::new((*(data as *mut bool)).clone())) as *mut std::ffi::c_void
}

#[rustfmt::skip]
#[no_mangle]
pub unsafe extern "C" fn __bool_drop(data: *mut c_void) {
    drop(Box::from_raw(data as *mut bool))
}

#[rustfmt::skip]
#[no_mangle]
pub unsafe extern "C" fn __bool_eq(this: &std::ffi::c_void, other: &std::ffi::c_void) -> bool {
    *(this as *const std::ffi::c_void as *const bool) == *(other as *const std::ffi::c_void as *const bool)
}

#[rustfmt::skip]
#[no_mangle]
pub unsafe extern "C" fn __bool_assign(registers: *mut __RegularValue) {
    let registers = std::slice::from_raw_parts_mut(registers, 2);
    *registers[0].downcast_temp_mut::<bool>(&__BOOL_VTABLE) = registers[1].downcast_bool()
}

#[rustfmt::skip]
#[no_mangle]
pub static __BOOL_VTABLE: __RegisterTyVTable = __RegisterTyVTable {
    primitive_value_to_bool: Some(__bool_primitive_value_to_bool),
    primitive_ref_to_bool: Some(__bool_primitive_ref_to_bool),
    primitive_value_to_box: Some(__bool_primitive_value_to_box),
    clone: __bool_clone,
    drop: __bool_drop,
    eq: __bool_eq,
    assign: __bool_assign,
    typename_str: "bool",
    typename_str_hash_u64: 729807561129781588,
};

#[rustfmt::skip]
impl __RegularValue {
    pub fn downcast_bool(&self) -> bool {
        todo!()
        // unsafe {
        //     if self.vtable.typename_str_hash_u64 != 729807561129781588 {
        //         panic!("expect `bool` but get {} instead", self.vtable.typename_str)
        //     }
        //     match self.data_kind {
        //         __RegisterDataKind::PrimitiveValue => self.data.as_bool,
        //         __RegisterDataKind::Leash
        //         | __RegisterDataKind::TempRef
        //         | __RegisterDataKind::TempMut
        //         | __RegisterDataKind::Box => *(self.data.as_ptr as *const bool),
        //         _ => panic!(),
        //     }
        // }
    }

    pub fn downcast_opt_bool(&self) -> Option<bool> {
        todo!()
        // unsafe {
        //     if self.vtable.typename_str_hash_u64 != 729807561129781588 {
        //         panic!("expect `bool` but get `{}` instead", self.vtable.typename_str)
        //     }
        //     match self.data_kind {
        //         __RegisterDataKind::PrimitiveValue => Some(self.data.as_bool),
        //         __RegisterDataKind::Leash
        //         | __RegisterDataKind::TempRef
        //         | __RegisterDataKind::TempMut
        //         | __RegisterDataKind::Box => Some(*(self.data.as_ptr as *const bool)),
        //         __RegisterDataKind::SomeNone => {
        //             assert_eq!(unsafe {self.data.as_number_of_somes}, 0);
        //             None
        //         },
        //         _ => panic!(),
        //     }
        // }
    }
}

// i32
#[rustfmt::skip]
#[no_mangle]
pub unsafe extern "C" fn __i32_primitive_value_to_bool(data: __RegisterData) -> bool {
    let data = data.as_i32;
    data != 0
}

#[rustfmt::skip]
#[no_mangle]
pub unsafe extern "C" fn __i32_primitive_ref_to_bool(data_ptr: *mut std::ffi::c_void) -> bool {
    let data = unsafe { *(data_ptr as *const i32) };
    data != 0
}

#[rustfmt::skip]
#[no_mangle]
pub unsafe extern "C" fn __i32_primitive_value_to_box(data: __RegisterData) -> *mut std::ffi::c_void {
    let data = data.as_i32;
    let ptr: *mut i32 = Box::<i32>::into_raw(Box::new(data));
    ptr as *mut std::ffi::c_void
}

#[rustfmt::skip]
#[no_mangle]
pub unsafe extern "C" fn __i32_clone(data: *mut c_void) -> *mut std::ffi::c_void {
    Box::<i32>::into_raw(Box::new((*(data as *mut i32)).clone())) as *mut std::ffi::c_void
}

#[rustfmt::skip]
#[no_mangle]
pub unsafe extern "C" fn __i32_drop(data: *mut c_void) {
    drop(Box::from_raw(data as *mut i32))
}

#[rustfmt::skip]
#[no_mangle]
pub unsafe extern "C" fn __i32_eq(this: &std::ffi::c_void, other: &std::ffi::c_void) -> bool {
    *(this as *const std::ffi::c_void as *const i32) == *(other as *const std::ffi::c_void as *const i32)
}

#[rustfmt::skip]
#[no_mangle]
pub unsafe extern "C" fn __i32_assign(registers: *mut __RegularValue) {
    let registers = std::slice::from_raw_parts_mut(registers, 2);
    *registers[0].downcast_temp_mut::<i32>(&__I32_VTABLE) = registers[1].downcast_i32()
}

#[rustfmt::skip]
#[no_mangle]
pub static __I32_VTABLE: __RegisterTyVTable = __RegisterTyVTable {
    primitive_value_to_bool: Some(__i32_primitive_value_to_bool),
    primitive_ref_to_bool: Some(__i32_primitive_ref_to_bool),
    primitive_value_to_box: Some(__i32_primitive_value_to_box),
    clone: __i32_clone,
    drop: __i32_drop,
    eq: __i32_eq,
    assign: __i32_assign,
    typename_str: "i32",
    typename_str_hash_u64: 6639413044669031007,
};

#[rustfmt::skip]
impl __RegularValue {
    pub fn downcast_i32(&self) -> i32 {
        unsafe {
            if self.vtable.typename_str_hash_u64 != 6639413044669031007 {
                panic!("expect `i32` but get {} instead", self.vtable.typename_str)
            }
            match self.data_kind {
                __RegisterDataKind::PrimitiveValue => self.data.as_i32,
                __RegisterDataKind::Leash
                | __RegisterDataKind::TempRef
                | __RegisterDataKind::TempMut
                | __RegisterDataKind::Box => *(self.data.as_ptr as *const i32),
                _ => panic!(),
            }
        }
    }

    pub fn downcast_opt_i32(&self) -> Option<i32> {
        unsafe {
            if self.vtable.typename_str_hash_u64 != 6639413044669031007 {
                panic!("expect `i32` but get `{}` instead", self.vtable.typename_str)
            }
            match self.data_kind {
                __RegisterDataKind::PrimitiveValue => Some(self.data.as_i32),
                __RegisterDataKind::Leash
                | __RegisterDataKind::TempRef
                | __RegisterDataKind::TempMut
                | __RegisterDataKind::Box => Some(*(self.data.as_ptr as *const i32)),
                __RegisterDataKind::SomeNone => {
                    assert_eq!(unsafe {self.data.as_number_of_somes}, 0);
                    None
                },
                _ => panic!(),
            }
        }
    }
}

// i64
#[rustfmt::skip]
#[no_mangle]
pub unsafe extern "C" fn __i64_primitive_value_to_bool(data: __RegisterData) -> bool {
    let data = data.as_i64;
    data != 0
}

#[rustfmt::skip]
#[no_mangle]
pub unsafe extern "C" fn __i64_primitive_ref_to_bool(data_ptr: *mut std::ffi::c_void) -> bool {
    let data = unsafe { *(data_ptr as *const i64) };
    data != 0
}

#[rustfmt::skip]
#[no_mangle]
pub unsafe extern "C" fn __i64_primitive_value_to_box(data: __RegisterData) -> *mut std::ffi::c_void {
    let data = data.as_i64;
    let ptr: *mut i64 = Box::<i64>::into_raw(Box::new(data));
    ptr as *mut std::ffi::c_void
}

#[rustfmt::skip]
#[no_mangle]
pub unsafe extern "C" fn __i64_clone(data: *mut c_void) -> *mut std::ffi::c_void {
    Box::<i64>::into_raw(Box::new((*(data as *mut i64)).clone())) as *mut std::ffi::c_void
}

#[rustfmt::skip]
#[no_mangle]
pub unsafe extern "C" fn __i64_drop(data: *mut c_void) {
    drop(Box::from_raw(data as *mut i64))
}

#[rustfmt::skip]
#[no_mangle]
pub unsafe extern "C" fn __i64_eq(this: &std::ffi::c_void, other: &std::ffi::c_void) -> bool {
    *(this as *const std::ffi::c_void as *const i64) == *(other as *const std::ffi::c_void as *const i64)
}

#[rustfmt::skip]
#[no_mangle]
pub unsafe extern "C" fn __i64_assign(registers: *mut __RegularValue) {
    let registers = std::slice::from_raw_parts_mut(registers, 2);
    *registers[0].downcast_temp_mut::<i64>(&__I64_VTABLE) = registers[1].downcast_i64()
}

#[rustfmt::skip]
#[no_mangle]
pub static __I64_VTABLE: __RegisterTyVTable = __RegisterTyVTable {
    primitive_value_to_bool: Some(__i64_primitive_value_to_bool),
    primitive_ref_to_bool: Some(__i64_primitive_ref_to_bool),
    primitive_value_to_box: Some(__i64_primitive_value_to_box),
    clone: __i64_clone,
    drop: __i64_drop,
    eq: __i64_eq,
    assign: __i64_assign,
    typename_str: "i64",
    typename_str_hash_u64: 9204872793588273300,
};

#[rustfmt::skip]
impl __RegularValue {
    pub fn downcast_i64(&self) -> i64 {
        unsafe {
            if self.vtable.typename_str_hash_u64 != 9204872793588273300 {
                panic!("expect `i64` but get {} instead", self.vtable.typename_str)
            }
            match self.data_kind {
                __RegisterDataKind::PrimitiveValue => self.data.as_i64,
                __RegisterDataKind::Leash
                | __RegisterDataKind::TempRef
                | __RegisterDataKind::TempMut
                | __RegisterDataKind::Box => *(self.data.as_ptr as *const i64),
                _ => panic!(),
            }
        }
    }

    pub fn downcast_opt_i64(&self) -> Option<i64> {
        unsafe {
            if self.vtable.typename_str_hash_u64 != 9204872793588273300 {
                panic!("expect `i64` but get `{}` instead", self.vtable.typename_str)
            }
            match self.data_kind {
                __RegisterDataKind::PrimitiveValue => Some(self.data.as_i64),
                __RegisterDataKind::Leash
                | __RegisterDataKind::TempRef
                | __RegisterDataKind::TempMut
                | __RegisterDataKind::Box => Some(*(self.data.as_ptr as *const i64)),
                __RegisterDataKind::SomeNone => {
                    assert_eq!(unsafe {self.data.as_number_of_somes}, 0);
                    None
                },
                _ => panic!(),
            }
        }
    }
}

// r32
#[rustfmt::skip]
#[no_mangle]
pub unsafe extern "C" fn __r32_primitive_value_to_bool(data: __RegisterData) -> bool {
    let data = data.as_r32;
    data != 0
}

#[rustfmt::skip]
#[no_mangle]
pub unsafe extern "C" fn __r32_primitive_ref_to_bool(data_ptr: *mut std::ffi::c_void) -> bool {
    let data = unsafe { *(data_ptr as *const r32) };
    data != 0
}

#[rustfmt::skip]
#[no_mangle]
pub unsafe extern "C" fn __r32_primitive_value_to_box(data: __RegisterData) -> *mut std::ffi::c_void {
    let data = data.as_r32;
    let ptr: *mut r32 = Box::<r32>::into_raw(Box::new(data));
    ptr as *mut std::ffi::c_void
}

#[rustfmt::skip]
#[no_mangle]
pub unsafe extern "C" fn __r32_clone(data: *mut c_void) -> *mut std::ffi::c_void {
    Box::<r32>::into_raw(Box::new((*(data as *mut r32)).clone())) as *mut std::ffi::c_void
}

#[rustfmt::skip]
#[no_mangle]
pub unsafe extern "C" fn __r32_drop(data: *mut c_void) {
    drop(Box::from_raw(data as *mut r32))
}

#[rustfmt::skip]
#[no_mangle]
pub unsafe extern "C" fn __r32_eq(this: &std::ffi::c_void, other: &std::ffi::c_void) -> bool {
    *(this as *const std::ffi::c_void as *const r32) == *(other as *const std::ffi::c_void as *const r32)
}

#[rustfmt::skip]
#[no_mangle]
pub unsafe extern "C" fn __r32_assign(registers: *mut __RegularValue) {
    let registers = std::slice::from_raw_parts_mut(registers, 2);
    *registers[0].downcast_temp_mut::<r32>(&__B32_VTABLE) = registers[1].downcast_r32()
}

#[rustfmt::skip]
#[no_mangle]
pub static __B32_VTABLE: __RegisterTyVTable = __RegisterTyVTable {
    primitive_value_to_bool: Some(__r32_primitive_value_to_bool),
    primitive_ref_to_bool: Some(__r32_primitive_ref_to_bool),
    primitive_value_to_box: Some(__r32_primitive_value_to_box),
    clone: __r32_clone,
    drop: __r32_drop,
    eq: __r32_eq,
    assign: __r32_assign,
    typename_str: "r32",
    typename_str_hash_u64: 9758498138566595375,
};

#[rustfmt::skip]
impl __RegularValue {
    pub fn downcast_r32(&self) -> r32 {
        unsafe {
            if self.vtable.typename_str_hash_u64 != 9758498138566595375 {
                panic!("expect `r32` but get {} instead", self.vtable.typename_str)
            }
            match self.data_kind {
                __RegisterDataKind::PrimitiveValue => self.data.as_r32,
                __RegisterDataKind::Leash
                | __RegisterDataKind::TempRef
                | __RegisterDataKind::TempMut
                | __RegisterDataKind::Box => *(self.data.as_ptr as *const r32),
                _ => panic!(),
            }
        }
    }

    pub fn downcast_opt_r32(&self) -> Option<r32> {
        unsafe {
            if self.vtable.typename_str_hash_u64 != 9758498138566595375 {
                panic!("expect `r32` but get `{}` instead", self.vtable.typename_str)
            }
            match self.data_kind {
                __RegisterDataKind::PrimitiveValue => Some(self.data.as_r32),
                __RegisterDataKind::Leash
                | __RegisterDataKind::TempRef
                | __RegisterDataKind::TempMut
                | __RegisterDataKind::Box => Some(*(self.data.as_ptr as *const r32)),
                __RegisterDataKind::SomeNone => {
                    assert_eq!(unsafe {self.data.as_number_of_somes}, 0);
                    None
                },
                _ => panic!(),
            }
        }
    }
}

// b64
#[rustfmt::skip]
#[no_mangle]
pub unsafe extern "C" fn __b64_primitive_value_to_bool(data: __RegisterData) -> bool {
    let data = data.as_b64;
    data != 0
}

#[rustfmt::skip]
#[no_mangle]
pub unsafe extern "C" fn __b64_primitive_ref_to_bool(data_ptr: *mut std::ffi::c_void) -> bool {
    let data = unsafe { *(data_ptr as *const b64) };
    data != 0
}

#[rustfmt::skip]
#[no_mangle]
pub unsafe extern "C" fn __b64_primitive_value_to_box(data: __RegisterData) -> *mut std::ffi::c_void {
    let data = data.as_b64;
    let ptr: *mut b64 = Box::<b64>::into_raw(Box::new(data));
    ptr as *mut std::ffi::c_void
}

#[rustfmt::skip]
#[no_mangle]
pub unsafe extern "C" fn __b64_clone(data: *mut c_void) -> *mut std::ffi::c_void {
    Box::<b64>::into_raw(Box::new((*(data as *mut b64)).clone())) as *mut std::ffi::c_void
}

#[rustfmt::skip]
#[no_mangle]
pub unsafe extern "C" fn __b64_drop(data: *mut c_void) {
    drop(Box::from_raw(data as *mut b64))
}

#[rustfmt::skip]
#[no_mangle]
pub unsafe extern "C" fn __b64_eq(this: &std::ffi::c_void, other: &std::ffi::c_void) -> bool {
    *(this as *const std::ffi::c_void as *const b64) == *(other as *const std::ffi::c_void as *const b64)
}

#[rustfmt::skip]
#[no_mangle]
pub unsafe extern "C" fn __b64_assign(registers: *mut __RegularValue) {
    let registers = std::slice::from_raw_parts_mut(registers, 2);
    *registers[0].downcast_temp_mut::<b64>(&__B64_VTABLE) = registers[1].downcast_b64()
}

#[rustfmt::skip]
#[no_mangle]
pub static __B64_VTABLE: __RegisterTyVTable = __RegisterTyVTable {
    primitive_value_to_bool: Some(__b64_primitive_value_to_bool),
    primitive_ref_to_bool: Some(__b64_primitive_ref_to_bool),
    primitive_value_to_box: Some(__b64_primitive_value_to_box),
    clone: __b64_clone,
    drop: __b64_drop,
    eq: __b64_eq,
    assign: __b64_assign,
    typename_str: "b64",
    typename_str_hash_u64: 11108470303398574121,
};

#[rustfmt::skip]
impl __RegularValue {
    pub fn downcast_b64(&self) -> b64 {
        unsafe {
            if self.vtable.typename_str_hash_u64 != 11108470303398574121 {
                panic!("expect `b64` but get {} instead", self.vtable.typename_str)
            }
            match self.data_kind {
                __RegisterDataKind::PrimitiveValue => self.data.as_b64,
                __RegisterDataKind::Leash
                | __RegisterDataKind::TempRef
                | __RegisterDataKind::TempMut
                | __RegisterDataKind::Box => *(self.data.as_ptr as *const b64),
                _ => panic!(),
            }
        }
    }

    pub fn downcast_opt_b64(&self) -> Option<b64> {
        unsafe {
            if self.vtable.typename_str_hash_u64 != 11108470303398574121 {
                panic!("expect `b64` but get `{}` instead", self.vtable.typename_str)
            }
            match self.data_kind {
                __RegisterDataKind::PrimitiveValue => Some(self.data.as_b64),
                __RegisterDataKind::Leash
                | __RegisterDataKind::TempRef
                | __RegisterDataKind::TempMut
                | __RegisterDataKind::Box => Some(*(self.data.as_ptr as *const b64)),
                __RegisterDataKind::SomeNone => {
                    assert_eq!(unsafe {self.data.as_number_of_somes}, 0);
                    None
                },
                _ => panic!(),
            }
        }
    }
}

// f32
#[rustfmt::skip]
#[no_mangle]
pub unsafe extern "C" fn __f32_primitive_value_to_bool(data: __RegisterData) -> bool {
    let data = data.as_not_nan_f32;
    data != 0.0
}

#[rustfmt::skip]
#[no_mangle]
pub unsafe extern "C" fn __f32_primitive_ref_to_bool(data_ptr: *mut std::ffi::c_void) -> bool {
    let data = unsafe { *(data_ptr as *const f32) };
    data != 0.0
}

#[rustfmt::skip]
#[no_mangle]
pub unsafe extern "C" fn __f32_primitive_value_to_box(data: __RegisterData) -> *mut std::ffi::c_void {
    let data = data.as_not_nan_f32;
    let ptr: *mut ordered_float::NotNan<f32> = Box::<ordered_float::NotNan<f32>>::into_raw(Box::new(data));
    ptr as *mut std::ffi::c_void
}

#[rustfmt::skip]
#[no_mangle]
pub unsafe extern "C" fn __f32_clone(data: *mut c_void) -> *mut std::ffi::c_void {
    Box::<f32>::into_raw(Box::new((*(data as *mut f32)).clone())) as *mut std::ffi::c_void
}

#[rustfmt::skip]
#[no_mangle]
pub unsafe extern "C" fn __f32_drop(data: *mut c_void) {
    drop(Box::from_raw(data as *mut f32))
}

#[rustfmt::skip]
#[no_mangle]
pub unsafe extern "C" fn __f32_eq(this: &std::ffi::c_void, other: &std::ffi::c_void) -> bool {
    *(this as *const std::ffi::c_void as *const f32) == *(other as *const std::ffi::c_void as *const f32)
}

#[rustfmt::skip]
#[no_mangle]
pub unsafe extern "C" fn __f32_assign(registers: *mut __RegularValue) {
    let registers = std::slice::from_raw_parts_mut(registers, 2);
    *registers[0].downcast_temp_mut::<f32>(&__F32_VTABLE) = registers[1].downcast_f32()
}

#[rustfmt::skip]
#[no_mangle]
pub static __F32_VTABLE: __RegisterTyVTable = __RegisterTyVTable {
    primitive_value_to_bool: Some(__f32_primitive_value_to_bool),
    primitive_ref_to_bool: Some(__f32_primitive_ref_to_bool),
    primitive_value_to_box: Some(__f32_primitive_value_to_box),
    clone: __f32_clone,
    drop: __f32_drop,
    eq: __f32_eq,
    assign: __f32_assign,
    typename_str: "f32",
    typename_str_hash_u64: 211483071870485656,
};

#[rustfmt::skip]
impl __RegularValue {
    pub fn downcast_f32(&self) -> f32 {
        unsafe {
            if self.vtable.typename_str_hash_u64 != 211483071870485656 {
                panic!("expect `f32` but get {} instead", self.vtable.typename_str)
            }
            match self.data_kind {
                __RegisterDataKind::PrimitiveValue => self.data.as_not_nan_f32.into_inner(),
                __RegisterDataKind::Leash
                | __RegisterDataKind::TempRef
                | __RegisterDataKind::TempMut
                | __RegisterDataKind::Box => *(self.data.as_ptr as *const f32),
                _ => panic!(),
            }
        }
    }

    pub fn downcast_opt_f32(&self) -> Option<f32> {
        unsafe {
            if self.vtable.typename_str_hash_u64 != 211483071870485656 {
                panic!("expect `f32` but get `{}` instead", self.vtable.typename_str)
            }
            match self.data_kind {
                __RegisterDataKind::PrimitiveValue => Some(self.data.as_not_nan_f32.into_inner()),
                __RegisterDataKind::Leash
                | __RegisterDataKind::TempRef
                | __RegisterDataKind::TempMut
                | __RegisterDataKind::Box => Some(*(self.data.as_ptr as *const f32)),
                __RegisterDataKind::SomeNone => {
                    assert_eq!(unsafe {self.data.as_number_of_somes}, 0);
                    None
                },
                _ => panic!(),
            }
        }
    }
}

// f64
#[rustfmt::skip]
#[no_mangle]
pub unsafe extern "C" fn __f64_primitive_value_to_bool(data: __RegisterData) -> bool {
    let data = data.as_f64;
    data != 0.0
}

#[rustfmt::skip]
#[no_mangle]
pub unsafe extern "C" fn __f64_primitive_ref_to_bool(data_ptr: *mut std::ffi::c_void) -> bool {
    let data = unsafe { *(data_ptr as *const f64) };
    data != 0.0
}

#[rustfmt::skip]
#[no_mangle]
pub unsafe extern "C" fn __f64_primitive_value_to_box(data: __RegisterData) -> *mut std::ffi::c_void {
    let data = data.as_f64;
    let ptr: *mut f64 = Box::<f64>::into_raw(Box::new(data));
    ptr as *mut std::ffi::c_void
}

#[rustfmt::skip]
#[no_mangle]
pub unsafe extern "C" fn __f64_clone(data: *mut c_void) -> *mut std::ffi::c_void {
    Box::<f64>::into_raw(Box::new((*(data as *mut f64)).clone())) as *mut std::ffi::c_void
}

#[rustfmt::skip]
#[no_mangle]
pub unsafe extern "C" fn __f64_drop(data: *mut c_void) {
    drop(Box::from_raw(data as *mut f64))
}

#[rustfmt::skip]
#[no_mangle]
pub unsafe extern "C" fn __f64_eq(this: &std::ffi::c_void, other: &std::ffi::c_void) -> bool {
    *(this as *const std::ffi::c_void as *const f64) == *(other as *const std::ffi::c_void as *const f64)
}

#[rustfmt::skip]
#[no_mangle]
pub unsafe extern "C" fn __f64_assign(registers: *mut __RegularValue) {
    let registers = std::slice::from_raw_parts_mut(registers, 2);
    *registers[0].downcast_temp_mut::<f64>(&__F64_VTABLE) = registers[1].downcast_f64()
}

#[rustfmt::skip]
#[no_mangle]
pub static __F64_VTABLE: __RegisterTyVTable = __RegisterTyVTable {
    primitive_value_to_bool: Some(__f64_primitive_value_to_bool),
    primitive_ref_to_bool: Some(__f64_primitive_ref_to_bool),
    primitive_value_to_box: Some(__f64_primitive_value_to_box),
    clone: __f64_clone,
    drop: __f64_drop,
    eq: __f64_eq,
    assign: __f64_assign,
    typename_str: "f64",
    typename_str_hash_u64: 14456281901843390161,
};

#[rustfmt::skip]
impl __RegularValue {
    pub fn downcast_f64(&self) -> f64 {
        unsafe {
            if self.vtable.typename_str_hash_u64 != 14456281901843390161 {
                panic!("expect `f64` but get {} instead", self.vtable.typename_str)
            }
            match self.data_kind {
                __RegisterDataKind::PrimitiveValue => self.data.as_f64,
                __RegisterDataKind::Leash
                | __RegisterDataKind::TempRef
                | __RegisterDataKind::TempMut
                | __RegisterDataKind::Box => *(self.data.as_ptr as *const f64),
                _ => panic!(),
            }
        }
    }

    pub fn downcast_opt_f64(&self) -> Option<f64> {
        unsafe {
            if self.vtable.typename_str_hash_u64 != 14456281901843390161 {
                panic!("expect `f64` but get `{}` instead", self.vtable.typename_str)
            }
            match self.data_kind {
                __RegisterDataKind::PrimitiveValue => Some(self.data.as_f64),
                __RegisterDataKind::Leash
                | __RegisterDataKind::TempRef
                | __RegisterDataKind::TempMut
                | __RegisterDataKind::Box => Some(*(self.data.as_ptr as *const f64)),
                __RegisterDataKind::SomeNone => {
                    assert_eq!(unsafe {self.data.as_number_of_somes}, 0);
                    None
                },
                _ => panic!(),
            }
        }
    }
}

// __VirtualFunction
#[rustfmt::skip]
#[no_mangle]
pub unsafe extern "C" fn __virtual_function_clone(data: *mut std::ffi::c_void) -> *mut std::ffi::c_void {
    Box::<__VirtualFunction>::into_raw(Box::new((*(data as *mut __VirtualFunction)).clone())) as *mut std::ffi::c_void
}
#[rustfmt::skip]
#[no_mangle]
pub unsafe extern "C" fn __virtual_function_drop(data: *mut std::ffi::c_void) {
    drop(Box::from_raw(data as *mut __VirtualFunction))
}
#[rustfmt::skip]
#[no_mangle]
pub unsafe extern "C" fn __virtual_function_eq(this: &std::ffi::c_void, other: &std::ffi::c_void) -> bool {
    *(this as *const std::ffi::c_void as *const __VirtualFunction) == *(other as *const std::ffi::c_void as *const __VirtualFunction)
}
#[rustfmt::skip]
#[no_mangle]
pub unsafe extern "C" fn __virtual_function_assign(registers: *mut __RegularValue) {
    let registers = std::slice::from_raw_parts_mut(registers, 2);
    *registers[0].downcast_temp_mut::<__VirtualFunction>(&__VIRTUAL_FUNCTION_VTABLE) = registers[1].downcast_move(&__VIRTUAL_FUNCTION_VTABLE)
}
#[rustfmt::skip]
#[no_mangle]
pub static __VIRTUAL_FUNCTION_VTABLE: __RegisterTyVTable = __RegisterTyVTable {
    primitive_value_to_bool: None,
    primitive_ref_to_bool: None,
    primitive_value_to_box: None,
    clone: __virtual_function_clone,
    drop: __virtual_function_drop,
    eq: __virtual_function_eq,
    assign: __virtual_function_assign,
    typename_str_hash_u64: 14269288641304277215,
    typename_str: "__VirtualFunction",
};

// __VirtualEnum
#[rustfmt::skip]
#[no_mangle]
pub unsafe extern "C" fn __virtual_enum_clone(data: *mut std::ffi::c_void) -> *mut std::ffi::c_void {
    Box::<__VirtualEnum>::into_raw(Box::new((*(data as *mut __VirtualEnum)).clone())) as *mut std::ffi::c_void
}
#[rustfmt::skip]
#[no_mangle]
pub unsafe extern "C" fn __virtual_enum_drop(data: *mut std::ffi::c_void) {
    drop(Box::from_raw(data as *mut __VirtualEnum))
}
#[rustfmt::skip]
#[no_mangle]
pub unsafe extern "C" fn __virtual_enum_eq(this: &std::ffi::c_void, other: &std::ffi::c_void) -> bool {
    *(this as *const std::ffi::c_void as *const __VirtualEnum) == *(other as *const std::ffi::c_void as *const __VirtualEnum)
}
#[rustfmt::skip]
#[no_mangle]
pub unsafe extern "C" fn __virtual_enum_assign(registers: *mut __RegularValue) {
    let registers = std::slice::from_raw_parts_mut(registers, 2);
    *registers[0].downcast_temp_mut::<__VirtualEnum>(&__VIRTUAL_ENUM_VTABLE) = registers[1].downcast_move(&__VIRTUAL_ENUM_VTABLE)
}
#[rustfmt::skip]
#[no_mangle]
pub static __VIRTUAL_ENUM_VTABLE: __RegisterTyVTable = __RegisterTyVTable {
    primitive_value_to_bool: None,
    primitive_ref_to_bool: None,
    primitive_value_to_box: None,
    clone: __virtual_enum_clone,
    drop: __virtual_enum_drop,
    eq: __virtual_enum_eq,
    assign: __virtual_enum_assign,
    typename_str_hash_u64: 10189591299398487822,
    typename_str: "__VirtualEnum",
};

// base

#[cfg(feature = "thin_fp")]
#[rustfmt::skip]
impl<Output: __StaticInfo> __StaticInfo for fn(
) -> Output {
    type __StaticSelf = fn(
    ) -> <Output as __StaticInfo>::__StaticSelf;

    fn __static_typename() -> std::borrow::Cow<'static, str> {
        todo!()
    }

    unsafe fn __transmute_static(self) -> Self::__StaticSelf {
        todo!()
    }
}

#[cfg(feature = "thin_fp")]
#[rustfmt::skip]
impl<Output: __StaticInfo> const ThinFp
    for fn() -> Output {
    fn __to_void_pointer(self) -> *const c_void {
        self as *const c_void
    }
}

#[cfg(feature = "thin_fp")]
#[rustfmt::skip]
impl<Output: __StaticInfo> const __BaseThinFp
    for fn() -> Output {
    type __CtxThinFp = fn(
        &dyn __EvalContext
    ) -> Output;
}

// ctx

#[cfg(feature = "thin_fp")]
#[rustfmt::skip]
impl<Output: __StaticInfo> __StaticInfo
    for fn(
        &dyn __EvalContext
    ) -> Output {
    type __StaticSelf = fn(
    ) -> <Output as __StaticInfo>::__StaticSelf;

    fn __static_typename() -> std::borrow::Cow<'static, str> {
        todo!()
    }

    unsafe fn __transmute_static(self) -> Self::__StaticSelf {
        todo!()
    }
}

#[cfg(feature = "thin_fp")]
#[rustfmt::skip]
impl<Output: __StaticInfo> const ThinFp
    for fn(
        &dyn __EvalContext
    ) -> Output {
    fn __to_void_pointer(self) -> *const c_void {
        self as *const c_void
    }
}

#[cfg(feature = "thin_fp")]
#[rustfmt::skip]
impl<Output: __StaticInfo> const __CtxThinFp
    for fn(
        &dyn __EvalContext
    ) -> Output {}

// base

#[cfg(feature = "thin_fp")]
#[rustfmt::skip]
impl<A0: __StaticInfo, Output: __StaticInfo> __StaticInfo for fn(A0
) -> Output {
    type __StaticSelf = fn(
        <A0 as __StaticInfo>::__StaticSelf, 
    ) -> <Output as __StaticInfo>::__StaticSelf;

    fn __static_typename() -> std::borrow::Cow<'static, str> {
        todo!()
    }

    unsafe fn __transmute_static(self) -> Self::__StaticSelf {
        todo!()
    }
}

#[cfg(feature = "thin_fp")]
#[rustfmt::skip]
impl<A0: __StaticInfo, Output: __StaticInfo> const ThinFp
    for fn(A0) -> Output {
    fn __to_void_pointer(self) -> *const c_void {
        self as *const c_void
    }
}

#[cfg(feature = "thin_fp")]
#[rustfmt::skip]
impl<A0: __StaticInfo, Output: __StaticInfo> const __BaseThinFp
    for fn(A0) -> Output {
    type __CtxThinFp = fn(
        
        <A0 as __StaticInfo>::__StaticSelf, &dyn __EvalContext
    ) -> Output;
}

// ctx

#[cfg(feature = "thin_fp")]
#[rustfmt::skip]
impl<A0: __StaticInfo, Output: __StaticInfo> __StaticInfo
    for fn(
        A0, &dyn __EvalContext
    ) -> Output {
    type __StaticSelf = fn(
        <A0 as __StaticInfo>::__StaticSelf, 
    ) -> <Output as __StaticInfo>::__StaticSelf;

    fn __static_typename() -> std::borrow::Cow<'static, str> {
        todo!()
    }

    unsafe fn __transmute_static(self) -> Self::__StaticSelf {
        todo!()
    }
}

#[cfg(feature = "thin_fp")]
#[rustfmt::skip]
impl<A0: __StaticInfo, Output: __StaticInfo> const ThinFp
    for fn(
        A0, &dyn __EvalContext
    ) -> Output {
    fn __to_void_pointer(self) -> *const c_void {
        self as *const c_void
    }
}

#[cfg(feature = "thin_fp")]
#[rustfmt::skip]
impl<A0: __StaticInfo, Output: __StaticInfo> const __CtxThinFp
    for fn(
        A0, &dyn __EvalContext
    ) -> Output {}

// base

#[cfg(feature = "thin_fp")]
#[rustfmt::skip]
impl<A0: __StaticInfo, A1: __StaticInfo, Output: __StaticInfo> __StaticInfo for fn(A0, A1
) -> Output {
    type __StaticSelf = fn(
        <A0 as __StaticInfo>::__StaticSelf, 
        <A1 as __StaticInfo>::__StaticSelf, 
    ) -> <Output as __StaticInfo>::__StaticSelf;

    fn __static_typename() -> std::borrow::Cow<'static, str> {
        todo!()
    }

    unsafe fn __transmute_static(self) -> Self::__StaticSelf {
        todo!()
    }
}

#[cfg(feature = "thin_fp")]
#[rustfmt::skip]
impl<A0: __StaticInfo, A1: __StaticInfo, Output: __StaticInfo> const ThinFp
    for fn(A0, A1) -> Output {
    fn __to_void_pointer(self) -> *const c_void {
        self as *const c_void
    }
}

#[cfg(feature = "thin_fp")]
#[rustfmt::skip]
impl<A0: __StaticInfo, A1: __StaticInfo, Output: __StaticInfo> const __BaseThinFp
    for fn(A0, A1) -> Output {
    type __CtxThinFp = fn(
        
        <A0 as __StaticInfo>::__StaticSelf, 
        <A1 as __StaticInfo>::__StaticSelf, &dyn __EvalContext
    ) -> Output;
}

// ctx

#[cfg(feature = "thin_fp")]
#[rustfmt::skip]
impl<A0: __StaticInfo, A1: __StaticInfo, Output: __StaticInfo> __StaticInfo
    for fn(
        A0, A1, &dyn __EvalContext
    ) -> Output {
    type __StaticSelf = fn(
        <A0 as __StaticInfo>::__StaticSelf, 
        <A1 as __StaticInfo>::__StaticSelf, 
    ) -> <Output as __StaticInfo>::__StaticSelf;

    fn __static_typename() -> std::borrow::Cow<'static, str> {
        todo!()
    }

    unsafe fn __transmute_static(self) -> Self::__StaticSelf {
        todo!()
    }
}

#[cfg(feature = "thin_fp")]
#[rustfmt::skip]
impl<A0: __StaticInfo, A1: __StaticInfo, Output: __StaticInfo> const ThinFp
    for fn(
        A0, A1, &dyn __EvalContext
    ) -> Output {
    fn __to_void_pointer(self) -> *const c_void {
        self as *const c_void
    }
}

#[cfg(feature = "thin_fp")]
#[rustfmt::skip]
impl<A0: __StaticInfo, A1: __StaticInfo, Output: __StaticInfo> const __CtxThinFp
    for fn(
        A0, A1, &dyn __EvalContext
    ) -> Output {}

// base

#[cfg(feature = "thin_fp")]
#[rustfmt::skip]
impl<A0: __StaticInfo, A1: __StaticInfo, A2: __StaticInfo, Output: __StaticInfo> __StaticInfo for fn(A0, A1, A2
) -> Output {
    type __StaticSelf = fn(
        <A0 as __StaticInfo>::__StaticSelf, 
        <A1 as __StaticInfo>::__StaticSelf, 
        <A2 as __StaticInfo>::__StaticSelf, 
    ) -> <Output as __StaticInfo>::__StaticSelf;

    fn __static_typename() -> std::borrow::Cow<'static, str> {
        todo!()
    }

    unsafe fn __transmute_static(self) -> Self::__StaticSelf {
        todo!()
    }
}

#[cfg(feature = "thin_fp")]
#[rustfmt::skip]
impl<A0: __StaticInfo, A1: __StaticInfo, A2: __StaticInfo, Output: __StaticInfo> const ThinFp
    for fn(A0, A1, A2) -> Output {
    fn __to_void_pointer(self) -> *const c_void {
        self as *const c_void
    }
}

#[cfg(feature = "thin_fp")]
#[rustfmt::skip]
impl<A0: __StaticInfo, A1: __StaticInfo, A2: __StaticInfo, Output: __StaticInfo> const __BaseThinFp
    for fn(A0, A1, A2) -> Output {
    type __CtxThinFp = fn(
        
        <A0 as __StaticInfo>::__StaticSelf, 
        <A1 as __StaticInfo>::__StaticSelf, 
        <A2 as __StaticInfo>::__StaticSelf, &dyn __EvalContext
    ) -> Output;
}

// ctx

#[cfg(feature = "thin_fp")]
#[rustfmt::skip]
impl<A0: __StaticInfo, A1: __StaticInfo, A2: __StaticInfo, Output: __StaticInfo> __StaticInfo
    for fn(
        A0, A1, A2, &dyn __EvalContext
    ) -> Output {
    type __StaticSelf = fn(
        <A0 as __StaticInfo>::__StaticSelf, 
        <A1 as __StaticInfo>::__StaticSelf, 
        <A2 as __StaticInfo>::__StaticSelf, 
    ) -> <Output as __StaticInfo>::__StaticSelf;

    fn __static_typename() -> std::borrow::Cow<'static, str> {
        todo!()
    }

    unsafe fn __transmute_static(self) -> Self::__StaticSelf {
        todo!()
    }
}

#[cfg(feature = "thin_fp")]
#[rustfmt::skip]
impl<A0: __StaticInfo, A1: __StaticInfo, A2: __StaticInfo, Output: __StaticInfo> const ThinFp
    for fn(
        A0, A1, A2, &dyn __EvalContext
    ) -> Output {
    fn __to_void_pointer(self) -> *const c_void {
        self as *const c_void
    }
}

#[cfg(feature = "thin_fp")]
#[rustfmt::skip]
impl<A0: __StaticInfo, A1: __StaticInfo, A2: __StaticInfo, Output: __StaticInfo> const __CtxThinFp
    for fn(
        A0, A1, A2, &dyn __EvalContext
    ) -> Output {}

// base

#[cfg(feature = "thin_fp")]
#[rustfmt::skip]
impl<A0: __StaticInfo, A1: __StaticInfo, A2: __StaticInfo, A3: __StaticInfo, Output: __StaticInfo> __StaticInfo for fn(A0, A1, A2, A3
) -> Output {
    type __StaticSelf = fn(
        <A0 as __StaticInfo>::__StaticSelf, 
        <A1 as __StaticInfo>::__StaticSelf, 
        <A2 as __StaticInfo>::__StaticSelf, 
        <A3 as __StaticInfo>::__StaticSelf, 
    ) -> <Output as __StaticInfo>::__StaticSelf;

    fn __static_typename() -> std::borrow::Cow<'static, str> {
        todo!()
    }

    unsafe fn __transmute_static(self) -> Self::__StaticSelf {
        todo!()
    }
}

#[cfg(feature = "thin_fp")]
#[rustfmt::skip]
impl<A0: __StaticInfo, A1: __StaticInfo, A2: __StaticInfo, A3: __StaticInfo, Output: __StaticInfo> const ThinFp
    for fn(A0, A1, A2, A3) -> Output {
    fn __to_void_pointer(self) -> *const c_void {
        self as *const c_void
    }
}

#[cfg(feature = "thin_fp")]
#[rustfmt::skip]
impl<A0: __StaticInfo, A1: __StaticInfo, A2: __StaticInfo, A3: __StaticInfo, Output: __StaticInfo> const __BaseThinFp
    for fn(A0, A1, A2, A3) -> Output {
    type __CtxThinFp = fn(
        
        <A0 as __StaticInfo>::__StaticSelf, 
        <A1 as __StaticInfo>::__StaticSelf, 
        <A2 as __StaticInfo>::__StaticSelf, 
        <A3 as __StaticInfo>::__StaticSelf, &dyn __EvalContext
    ) -> Output;
}

// ctx

#[cfg(feature = "thin_fp")]
#[rustfmt::skip]
impl<A0: __StaticInfo, A1: __StaticInfo, A2: __StaticInfo, A3: __StaticInfo, Output: __StaticInfo> __StaticInfo
    for fn(
        A0, A1, A2, A3, &dyn __EvalContext
    ) -> Output {
    type __StaticSelf = fn(
        <A0 as __StaticInfo>::__StaticSelf, 
        <A1 as __StaticInfo>::__StaticSelf, 
        <A2 as __StaticInfo>::__StaticSelf, 
        <A3 as __StaticInfo>::__StaticSelf, 
    ) -> <Output as __StaticInfo>::__StaticSelf;

    fn __static_typename() -> std::borrow::Cow<'static, str> {
        todo!()
    }

    unsafe fn __transmute_static(self) -> Self::__StaticSelf {
        todo!()
    }
}

#[cfg(feature = "thin_fp")]
#[rustfmt::skip]
impl<A0: __StaticInfo, A1: __StaticInfo, A2: __StaticInfo, A3: __StaticInfo, Output: __StaticInfo> const ThinFp
    for fn(
        A0, A1, A2, A3, &dyn __EvalContext
    ) -> Output {
    fn __to_void_pointer(self) -> *const c_void {
        self as *const c_void
    }
}

#[cfg(feature = "thin_fp")]
#[rustfmt::skip]
impl<A0: __StaticInfo, A1: __StaticInfo, A2: __StaticInfo, A3: __StaticInfo, Output: __StaticInfo> const __CtxThinFp
    for fn(
        A0, A1, A2, A3, &dyn __EvalContext
    ) -> Output {}

// base

#[cfg(feature = "thin_fp")]
#[rustfmt::skip]
impl<A0: __StaticInfo, A1: __StaticInfo, A2: __StaticInfo, A3: __StaticInfo, A4: __StaticInfo, Output: __StaticInfo> __StaticInfo for fn(A0, A1, A2, A3, A4
) -> Output {
    type __StaticSelf = fn(
        <A0 as __StaticInfo>::__StaticSelf, 
        <A1 as __StaticInfo>::__StaticSelf, 
        <A2 as __StaticInfo>::__StaticSelf, 
        <A3 as __StaticInfo>::__StaticSelf, 
        <A4 as __StaticInfo>::__StaticSelf, 
    ) -> <Output as __StaticInfo>::__StaticSelf;

    fn __static_typename() -> std::borrow::Cow<'static, str> {
        todo!()
    }

    unsafe fn __transmute_static(self) -> Self::__StaticSelf {
        todo!()
    }
}

#[cfg(feature = "thin_fp")]
#[rustfmt::skip]
impl<A0: __StaticInfo, A1: __StaticInfo, A2: __StaticInfo, A3: __StaticInfo, A4: __StaticInfo, Output: __StaticInfo> const ThinFp
    for fn(A0, A1, A2, A3, A4) -> Output {
    fn __to_void_pointer(self) -> *const c_void {
        self as *const c_void
    }
}

#[cfg(feature = "thin_fp")]
#[rustfmt::skip]
impl<A0: __StaticInfo, A1: __StaticInfo, A2: __StaticInfo, A3: __StaticInfo, A4: __StaticInfo, Output: __StaticInfo> const __BaseThinFp
    for fn(A0, A1, A2, A3, A4) -> Output {
    type __CtxThinFp = fn(
        
        <A0 as __StaticInfo>::__StaticSelf, 
        <A1 as __StaticInfo>::__StaticSelf, 
        <A2 as __StaticInfo>::__StaticSelf, 
        <A3 as __StaticInfo>::__StaticSelf, 
        <A4 as __StaticInfo>::__StaticSelf, &dyn __EvalContext
    ) -> Output;
}

// ctx

#[cfg(feature = "thin_fp")]
#[rustfmt::skip]
impl<A0: __StaticInfo, A1: __StaticInfo, A2: __StaticInfo, A3: __StaticInfo, A4: __StaticInfo, Output: __StaticInfo> __StaticInfo
    for fn(
        A0, A1, A2, A3, A4, &dyn __EvalContext
    ) -> Output {
    type __StaticSelf = fn(
        <A0 as __StaticInfo>::__StaticSelf, 
        <A1 as __StaticInfo>::__StaticSelf, 
        <A2 as __StaticInfo>::__StaticSelf, 
        <A3 as __StaticInfo>::__StaticSelf, 
        <A4 as __StaticInfo>::__StaticSelf, 
    ) -> <Output as __StaticInfo>::__StaticSelf;

    fn __static_typename() -> std::borrow::Cow<'static, str> {
        todo!()
    }

    unsafe fn __transmute_static(self) -> Self::__StaticSelf {
        todo!()
    }
}

#[cfg(feature = "thin_fp")]
#[rustfmt::skip]
impl<A0: __StaticInfo, A1: __StaticInfo, A2: __StaticInfo, A3: __StaticInfo, A4: __StaticInfo, Output: __StaticInfo> const ThinFp
    for fn(
        A0, A1, A2, A3, A4, &dyn __EvalContext
    ) -> Output {
    fn __to_void_pointer(self) -> *const c_void {
        self as *const c_void
    }
}

#[cfg(feature = "thin_fp")]
#[rustfmt::skip]
impl<A0: __StaticInfo, A1: __StaticInfo, A2: __StaticInfo, A3: __StaticInfo, A4: __StaticInfo, Output: __StaticInfo> const __CtxThinFp
    for fn(
        A0, A1, A2, A3, A4, &dyn __EvalContext
    ) -> Output {}

// base

#[cfg(feature = "thin_fp")]
#[rustfmt::skip]
impl<A0: __StaticInfo, A1: __StaticInfo, A2: __StaticInfo, A3: __StaticInfo, A4: __StaticInfo, A5: __StaticInfo, Output: __StaticInfo> __StaticInfo for fn(A0, A1, A2, A3, A4, A5
) -> Output {
    type __StaticSelf = fn(
        <A0 as __StaticInfo>::__StaticSelf, 
        <A1 as __StaticInfo>::__StaticSelf, 
        <A2 as __StaticInfo>::__StaticSelf, 
        <A3 as __StaticInfo>::__StaticSelf, 
        <A4 as __StaticInfo>::__StaticSelf, 
        <A5 as __StaticInfo>::__StaticSelf, 
    ) -> <Output as __StaticInfo>::__StaticSelf;

    fn __static_typename() -> std::borrow::Cow<'static, str> {
        todo!()
    }

    unsafe fn __transmute_static(self) -> Self::__StaticSelf {
        todo!()
    }
}

#[cfg(feature = "thin_fp")]
#[rustfmt::skip]
impl<A0: __StaticInfo, A1: __StaticInfo, A2: __StaticInfo, A3: __StaticInfo, A4: __StaticInfo, A5: __StaticInfo, Output: __StaticInfo> const ThinFp
    for fn(A0, A1, A2, A3, A4, A5) -> Output {
    fn __to_void_pointer(self) -> *const c_void {
        self as *const c_void
    }
}

#[cfg(feature = "thin_fp")]
#[rustfmt::skip]
impl<A0: __StaticInfo, A1: __StaticInfo, A2: __StaticInfo, A3: __StaticInfo, A4: __StaticInfo, A5: __StaticInfo, Output: __StaticInfo> const __BaseThinFp
    for fn(A0, A1, A2, A3, A4, A5) -> Output {
    type __CtxThinFp = fn(
        
        <A0 as __StaticInfo>::__StaticSelf, 
        <A1 as __StaticInfo>::__StaticSelf, 
        <A2 as __StaticInfo>::__StaticSelf, 
        <A3 as __StaticInfo>::__StaticSelf, 
        <A4 as __StaticInfo>::__StaticSelf, 
        <A5 as __StaticInfo>::__StaticSelf, &dyn __EvalContext
    ) -> Output;
}

// ctx

#[cfg(feature = "thin_fp")]
#[rustfmt::skip]
impl<A0: __StaticInfo, A1: __StaticInfo, A2: __StaticInfo, A3: __StaticInfo, A4: __StaticInfo, A5: __StaticInfo, Output: __StaticInfo> __StaticInfo
    for fn(
        A0, A1, A2, A3, A4, A5, &dyn __EvalContext
    ) -> Output {
    type __StaticSelf = fn(
        <A0 as __StaticInfo>::__StaticSelf, 
        <A1 as __StaticInfo>::__StaticSelf, 
        <A2 as __StaticInfo>::__StaticSelf, 
        <A3 as __StaticInfo>::__StaticSelf, 
        <A4 as __StaticInfo>::__StaticSelf, 
        <A5 as __StaticInfo>::__StaticSelf, 
    ) -> <Output as __StaticInfo>::__StaticSelf;

    fn __static_typename() -> std::borrow::Cow<'static, str> {
        todo!()
    }

    unsafe fn __transmute_static(self) -> Self::__StaticSelf {
        todo!()
    }
}

#[cfg(feature = "thin_fp")]
#[rustfmt::skip]
impl<A0: __StaticInfo, A1: __StaticInfo, A2: __StaticInfo, A3: __StaticInfo, A4: __StaticInfo, A5: __StaticInfo, Output: __StaticInfo> const ThinFp
    for fn(
        A0, A1, A2, A3, A4, A5, &dyn __EvalContext
    ) -> Output {
    fn __to_void_pointer(self) -> *const c_void {
        self as *const c_void
    }
}

#[cfg(feature = "thin_fp")]
#[rustfmt::skip]
impl<A0: __StaticInfo, A1: __StaticInfo, A2: __StaticInfo, A3: __StaticInfo, A4: __StaticInfo, A5: __StaticInfo, Output: __StaticInfo> const __CtxThinFp
    for fn(
        A0, A1, A2, A3, A4, A5, &dyn __EvalContext
    ) -> Output {}

// base

#[cfg(feature = "thin_fp")]
#[rustfmt::skip]
impl<A0: __StaticInfo, A1: __StaticInfo, A2: __StaticInfo, A3: __StaticInfo, A4: __StaticInfo, A5: __StaticInfo, A6: __StaticInfo, Output: __StaticInfo> __StaticInfo for fn(A0, A1, A2, A3, A4, A5, A6
) -> Output {
    type __StaticSelf = fn(
        <A0 as __StaticInfo>::__StaticSelf, 
        <A1 as __StaticInfo>::__StaticSelf, 
        <A2 as __StaticInfo>::__StaticSelf, 
        <A3 as __StaticInfo>::__StaticSelf, 
        <A4 as __StaticInfo>::__StaticSelf, 
        <A5 as __StaticInfo>::__StaticSelf, 
        <A6 as __StaticInfo>::__StaticSelf, 
    ) -> <Output as __StaticInfo>::__StaticSelf;

    fn __static_typename() -> std::borrow::Cow<'static, str> {
        todo!()
    }

    unsafe fn __transmute_static(self) -> Self::__StaticSelf {
        todo!()
    }
}

#[cfg(feature = "thin_fp")]
#[rustfmt::skip]
impl<A0: __StaticInfo, A1: __StaticInfo, A2: __StaticInfo, A3: __StaticInfo, A4: __StaticInfo, A5: __StaticInfo, A6: __StaticInfo, Output: __StaticInfo> const ThinFp
    for fn(A0, A1, A2, A3, A4, A5, A6) -> Output {
    fn __to_void_pointer(self) -> *const c_void {
        self as *const c_void
    }
}

#[cfg(feature = "thin_fp")]
#[rustfmt::skip]
impl<A0: __StaticInfo, A1: __StaticInfo, A2: __StaticInfo, A3: __StaticInfo, A4: __StaticInfo, A5: __StaticInfo, A6: __StaticInfo, Output: __StaticInfo> const __BaseThinFp
    for fn(A0, A1, A2, A3, A4, A5, A6) -> Output {
    type __CtxThinFp = fn(
        
        <A0 as __StaticInfo>::__StaticSelf, 
        <A1 as __StaticInfo>::__StaticSelf, 
        <A2 as __StaticInfo>::__StaticSelf, 
        <A3 as __StaticInfo>::__StaticSelf, 
        <A4 as __StaticInfo>::__StaticSelf, 
        <A5 as __StaticInfo>::__StaticSelf, 
        <A6 as __StaticInfo>::__StaticSelf, &dyn __EvalContext
    ) -> Output;
}

// ctx

#[cfg(feature = "thin_fp")]
#[rustfmt::skip]
impl<A0: __StaticInfo, A1: __StaticInfo, A2: __StaticInfo, A3: __StaticInfo, A4: __StaticInfo, A5: __StaticInfo, A6: __StaticInfo, Output: __StaticInfo> __StaticInfo
    for fn(
        A0, A1, A2, A3, A4, A5, A6, &dyn __EvalContext
    ) -> Output {
    type __StaticSelf = fn(
        <A0 as __StaticInfo>::__StaticSelf, 
        <A1 as __StaticInfo>::__StaticSelf, 
        <A2 as __StaticInfo>::__StaticSelf, 
        <A3 as __StaticInfo>::__StaticSelf, 
        <A4 as __StaticInfo>::__StaticSelf, 
        <A5 as __StaticInfo>::__StaticSelf, 
        <A6 as __StaticInfo>::__StaticSelf, 
    ) -> <Output as __StaticInfo>::__StaticSelf;

    fn __static_typename() -> std::borrow::Cow<'static, str> {
        todo!()
    }

    unsafe fn __transmute_static(self) -> Self::__StaticSelf {
        todo!()
    }
}

#[cfg(feature = "thin_fp")]
#[rustfmt::skip]
impl<A0: __StaticInfo, A1: __StaticInfo, A2: __StaticInfo, A3: __StaticInfo, A4: __StaticInfo, A5: __StaticInfo, A6: __StaticInfo, Output: __StaticInfo> const ThinFp
    for fn(
        A0, A1, A2, A3, A4, A5, A6, &dyn __EvalContext
    ) -> Output {
    fn __to_void_pointer(self) -> *const c_void {
        self as *const c_void
    }
}

#[cfg(feature = "thin_fp")]
#[rustfmt::skip]
impl<A0: __StaticInfo, A1: __StaticInfo, A2: __StaticInfo, A3: __StaticInfo, A4: __StaticInfo, A5: __StaticInfo, A6: __StaticInfo, Output: __StaticInfo> const __CtxThinFp
    for fn(
        A0, A1, A2, A3, A4, A5, A6, &dyn __EvalContext
    ) -> Output {}

// base

#[cfg(feature = "thin_fp")]
#[rustfmt::skip]
impl<A0: __StaticInfo, A1: __StaticInfo, A2: __StaticInfo, A3: __StaticInfo, A4: __StaticInfo, A5: __StaticInfo, A6: __StaticInfo, A7: __StaticInfo, Output: __StaticInfo> __StaticInfo for fn(A0, A1, A2, A3, A4, A5, A6, A7
) -> Output {
    type __StaticSelf = fn(
        <A0 as __StaticInfo>::__StaticSelf, 
        <A1 as __StaticInfo>::__StaticSelf, 
        <A2 as __StaticInfo>::__StaticSelf, 
        <A3 as __StaticInfo>::__StaticSelf, 
        <A4 as __StaticInfo>::__StaticSelf, 
        <A5 as __StaticInfo>::__StaticSelf, 
        <A6 as __StaticInfo>::__StaticSelf, 
        <A7 as __StaticInfo>::__StaticSelf, 
    ) -> <Output as __StaticInfo>::__StaticSelf;

    fn __static_typename() -> std::borrow::Cow<'static, str> {
        todo!()
    }

    unsafe fn __transmute_static(self) -> Self::__StaticSelf {
        todo!()
    }
}

#[cfg(feature = "thin_fp")]
#[rustfmt::skip]
impl<A0: __StaticInfo, A1: __StaticInfo, A2: __StaticInfo, A3: __StaticInfo, A4: __StaticInfo, A5: __StaticInfo, A6: __StaticInfo, A7: __StaticInfo, Output: __StaticInfo> const ThinFp
    for fn(A0, A1, A2, A3, A4, A5, A6, A7) -> Output {
    fn __to_void_pointer(self) -> *const c_void {
        self as *const c_void
    }
}

#[cfg(feature = "thin_fp")]
#[rustfmt::skip]
impl<A0: __StaticInfo, A1: __StaticInfo, A2: __StaticInfo, A3: __StaticInfo, A4: __StaticInfo, A5: __StaticInfo, A6: __StaticInfo, A7: __StaticInfo, Output: __StaticInfo> const __BaseThinFp
    for fn(A0, A1, A2, A3, A4, A5, A6, A7) -> Output {
    type __CtxThinFp = fn(
        
        <A0 as __StaticInfo>::__StaticSelf, 
        <A1 as __StaticInfo>::__StaticSelf, 
        <A2 as __StaticInfo>::__StaticSelf, 
        <A3 as __StaticInfo>::__StaticSelf, 
        <A4 as __StaticInfo>::__StaticSelf, 
        <A5 as __StaticInfo>::__StaticSelf, 
        <A6 as __StaticInfo>::__StaticSelf, 
        <A7 as __StaticInfo>::__StaticSelf, &dyn __EvalContext
    ) -> Output;
}

// ctx

#[cfg(feature = "thin_fp")]
#[rustfmt::skip]
impl<A0: __StaticInfo, A1: __StaticInfo, A2: __StaticInfo, A3: __StaticInfo, A4: __StaticInfo, A5: __StaticInfo, A6: __StaticInfo, A7: __StaticInfo, Output: __StaticInfo> __StaticInfo
    for fn(
        A0, A1, A2, A3, A4, A5, A6, A7, &dyn __EvalContext
    ) -> Output {
    type __StaticSelf = fn(
        <A0 as __StaticInfo>::__StaticSelf, 
        <A1 as __StaticInfo>::__StaticSelf, 
        <A2 as __StaticInfo>::__StaticSelf, 
        <A3 as __StaticInfo>::__StaticSelf, 
        <A4 as __StaticInfo>::__StaticSelf, 
        <A5 as __StaticInfo>::__StaticSelf, 
        <A6 as __StaticInfo>::__StaticSelf, 
        <A7 as __StaticInfo>::__StaticSelf, 
    ) -> <Output as __StaticInfo>::__StaticSelf;

    fn __static_typename() -> std::borrow::Cow<'static, str> {
        todo!()
    }

    unsafe fn __transmute_static(self) -> Self::__StaticSelf {
        todo!()
    }
}

#[cfg(feature = "thin_fp")]
#[rustfmt::skip]
impl<A0: __StaticInfo, A1: __StaticInfo, A2: __StaticInfo, A3: __StaticInfo, A4: __StaticInfo, A5: __StaticInfo, A6: __StaticInfo, A7: __StaticInfo, Output: __StaticInfo> const ThinFp
    for fn(
        A0, A1, A2, A3, A4, A5, A6, A7, &dyn __EvalContext
    ) -> Output {
    fn __to_void_pointer(self) -> *const c_void {
        self as *const c_void
    }
}

#[cfg(feature = "thin_fp")]
#[rustfmt::skip]
impl<A0: __StaticInfo, A1: __StaticInfo, A2: __StaticInfo, A3: __StaticInfo, A4: __StaticInfo, A5: __StaticInfo, A6: __StaticInfo, A7: __StaticInfo, Output: __StaticInfo> const __CtxThinFp
    for fn(
        A0, A1, A2, A3, A4, A5, A6, A7, &dyn __EvalContext
    ) -> Output {}

// base

#[cfg(feature = "thin_fp")]
#[rustfmt::skip]
impl<A0: __StaticInfo, A1: __StaticInfo, A2: __StaticInfo, A3: __StaticInfo, A4: __StaticInfo, A5: __StaticInfo, A6: __StaticInfo, A7: __StaticInfo, A8: __StaticInfo, Output: __StaticInfo> __StaticInfo for fn(A0, A1, A2, A3, A4, A5, A6, A7, A8
) -> Output {
    type __StaticSelf = fn(
        <A0 as __StaticInfo>::__StaticSelf, 
        <A1 as __StaticInfo>::__StaticSelf, 
        <A2 as __StaticInfo>::__StaticSelf, 
        <A3 as __StaticInfo>::__StaticSelf, 
        <A4 as __StaticInfo>::__StaticSelf, 
        <A5 as __StaticInfo>::__StaticSelf, 
        <A6 as __StaticInfo>::__StaticSelf, 
        <A7 as __StaticInfo>::__StaticSelf, 
        <A8 as __StaticInfo>::__StaticSelf, 
    ) -> <Output as __StaticInfo>::__StaticSelf;

    fn __static_typename() -> std::borrow::Cow<'static, str> {
        todo!()
    }

    unsafe fn __transmute_static(self) -> Self::__StaticSelf {
        todo!()
    }
}

#[cfg(feature = "thin_fp")]
#[rustfmt::skip]
impl<A0: __StaticInfo, A1: __StaticInfo, A2: __StaticInfo, A3: __StaticInfo, A4: __StaticInfo, A5: __StaticInfo, A6: __StaticInfo, A7: __StaticInfo, A8: __StaticInfo, Output: __StaticInfo> const ThinFp
    for fn(A0, A1, A2, A3, A4, A5, A6, A7, A8) -> Output {
    fn __to_void_pointer(self) -> *const c_void {
        self as *const c_void
    }
}

#[cfg(feature = "thin_fp")]
#[rustfmt::skip]
impl<A0: __StaticInfo, A1: __StaticInfo, A2: __StaticInfo, A3: __StaticInfo, A4: __StaticInfo, A5: __StaticInfo, A6: __StaticInfo, A7: __StaticInfo, A8: __StaticInfo, Output: __StaticInfo> const __BaseThinFp
    for fn(A0, A1, A2, A3, A4, A5, A6, A7, A8) -> Output {
    type __CtxThinFp = fn(
        
        <A0 as __StaticInfo>::__StaticSelf, 
        <A1 as __StaticInfo>::__StaticSelf, 
        <A2 as __StaticInfo>::__StaticSelf, 
        <A3 as __StaticInfo>::__StaticSelf, 
        <A4 as __StaticInfo>::__StaticSelf, 
        <A5 as __StaticInfo>::__StaticSelf, 
        <A6 as __StaticInfo>::__StaticSelf, 
        <A7 as __StaticInfo>::__StaticSelf, 
        <A8 as __StaticInfo>::__StaticSelf, &dyn __EvalContext
    ) -> Output;
}

// ctx

#[cfg(feature = "thin_fp")]
#[rustfmt::skip]
impl<A0: __StaticInfo, A1: __StaticInfo, A2: __StaticInfo, A3: __StaticInfo, A4: __StaticInfo, A5: __StaticInfo, A6: __StaticInfo, A7: __StaticInfo, A8: __StaticInfo, Output: __StaticInfo> __StaticInfo
    for fn(
        A0, A1, A2, A3, A4, A5, A6, A7, A8, &dyn __EvalContext
    ) -> Output {
    type __StaticSelf = fn(
        <A0 as __StaticInfo>::__StaticSelf, 
        <A1 as __StaticInfo>::__StaticSelf, 
        <A2 as __StaticInfo>::__StaticSelf, 
        <A3 as __StaticInfo>::__StaticSelf, 
        <A4 as __StaticInfo>::__StaticSelf, 
        <A5 as __StaticInfo>::__StaticSelf, 
        <A6 as __StaticInfo>::__StaticSelf, 
        <A7 as __StaticInfo>::__StaticSelf, 
        <A8 as __StaticInfo>::__StaticSelf, 
    ) -> <Output as __StaticInfo>::__StaticSelf;

    fn __static_typename() -> std::borrow::Cow<'static, str> {
        todo!()
    }

    unsafe fn __transmute_static(self) -> Self::__StaticSelf {
        todo!()
    }
}

#[cfg(feature = "thin_fp")]
#[rustfmt::skip]
impl<A0: __StaticInfo, A1: __StaticInfo, A2: __StaticInfo, A3: __StaticInfo, A4: __StaticInfo, A5: __StaticInfo, A6: __StaticInfo, A7: __StaticInfo, A8: __StaticInfo, Output: __StaticInfo> const ThinFp
    for fn(
        A0, A1, A2, A3, A4, A5, A6, A7, A8, &dyn __EvalContext
    ) -> Output {
    fn __to_void_pointer(self) -> *const c_void {
        self as *const c_void
    }
}

#[cfg(feature = "thin_fp")]
#[rustfmt::skip]
impl<A0: __StaticInfo, A1: __StaticInfo, A2: __StaticInfo, A3: __StaticInfo, A4: __StaticInfo, A5: __StaticInfo, A6: __StaticInfo, A7: __StaticInfo, A8: __StaticInfo, Output: __StaticInfo> const __CtxThinFp
    for fn(
        A0, A1, A2, A3, A4, A5, A6, A7, A8, &dyn __EvalContext
    ) -> Output {}
