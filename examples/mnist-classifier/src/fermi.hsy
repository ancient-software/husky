use crate::*

struct FermiMatchResult {
    matches: []?&ConcaveComponent,
    others: []&ConcaveComponent,
}

impl FermiMatchResult:
    // todo: change this to func
    proc norm -> f32:
        let mut norm = 0.0
        for i < self.others.ilen():
            norm = norm.max(self.others[i].norm)
        return norm
    
    proc rel_norm -> f32:
        let mut norm = 0.0
        for i < self.others.ilen():
            norm = norm.max(self.others[i].rel_norm)
        return norm

    proc angle_change_norm -> f32:
        let mut norm = 0.0
        for i < self.others.ilen():
            norm = norm.max(self.others[i].angle_change.abs())
        return norm

proc fermi_match(
    concave_components: &[]ConcaveComponent,
    templates: []((&ConcaveComponent) -> ?f32)
) -> FermiMatchResult:
    let mut others = concave_components.collect_refs()
    let mut matches = []?&ConcaveComponent()
    // todo: change this to `for template in templates` after introducing `for ... in` loop
    for i < templates.ilen():
        let template = templates[i]
        matches.push(others.pop_with_largest_opt_f32(template))
    return FermiMatchResult(matches, others)
