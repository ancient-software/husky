use crate::line_segment_sketch::*
use crate::line_segment_sketch::line_segment::*
use crate::line_segment_sketch::convexity::*
use crate::geom2d::*

struct ConcaveComponent:
    line_segment_sketch: &LineSegmentSketch
    strokes: [%]LineSegmentStroke

    func norm -> f32:
        // needs improvement
        this.hausdorff_norm
    
    func rel_norm -> f32:
        this.norm / this.displacement().norm()

    proc hausdorff_norm -> f32:
        let mut hausdorff_norm = 0.0
        let curve_start = strokes.firstx().start
        let curve_ls = this.line_segment()
        let dp_norm = curve_ls.displacement().norm()
        // todo: change this to iter().max()
        for strokes.start <= i < strokes.end:
            let point = strokes[i].end
            let point_dist = curve_ls.dist_to_point(point)
            if point_dist > hausdorff_norm:
                hausdorff_norm = point_dist
        return hausdorff_norm

    proc angle_change -> f32:
        let mut angle_change = 0.0
        let mut dp0 = this.strokes[strokes.start].displacement()
        // todo: change this for .. in ..[1..]
        for strokes.start < i < strokes.end:
            let dp = this.strokes[i].displacement()
            angle_change += dp0.angle_to(dp, true)
            dp0 = dp
        return angle_change
    
    proc bounding_box -> BoundingBox:
        let start_point = strokes.firstx().start
        let mut xmin = start_point.x
        let mut xmax = start_point.x
        let mut ymin = start_point.y
        let mut ymax = start_point.y
        for strokes.start <= i < strokes.end:
            let point = strokes[i].end
            xmin = xmin.min(point.x)
            xmax = xmax.max(point.x)
            ymin = ymin.min(point.y)
            ymax = ymax.max(point.y)
        return BoundingBox(
            ClosedRange(xmin, xmax), 
            ClosedRange(ymin, ymax),
        )
    
    func relative_bounding_box -> RelativeBoundingBox:
        this.line_segment_sketch.bounding_box.relative_range(this.bounding_box)

    func line_segment() -> LineSegment:
        LineSegment(
            strokes.firstx().start.clone(),
            strokes.lastx().end.clone()
        )

    func start() -> Point2d:
        strokes.firstx().start.clone()
    
    func end() -> Point2d:
        strokes.lastx().end.clone()
    
    func displacement() -> Vector2d:
        this.line_segment().displacement()

    func start_tangent() -> Vector2d:
        strokes.firstx().displacement()        

    func end_tangent() -> Vector2d:
        strokes.lastx().displacement()

    visual:
        strokes

proc find_concave_components(line_segment_sketch: &LineSegmentSketch) -> []ConcaveComponent:
    let mut concave_components = []ConcaveComponent()
    let L = line_segment_sketch.strokes.ilen()
    let mut start = 0
    let mut end = 1
    while start > -L and !is_convex(line_segment_sketch, start):
        start--
    let ccv_start = start
    while start < ccv_start + L:
        while end <= start+L and !is_convex(line_segment_sketch, end):
            end++
        if end > start + 1:
            concave_components.push(ConcaveComponent(
                line_segment_sketch,
                line_segment_sketch.strokes.cyclic_slice(start, end))
            )
        start = end
        end = start + 1
    return concave_components