struct RawContour:
    points: []Point2d

enum Direction:
    UP
    LEFT
    DOWN
    RIGHT


// pub func int int => Point2d point
// pub fn Point2dFromIJ28(i: int, j: int) -> Point2d
//   return Point2d(float(29 - j), float(29 - i))

func get_pixel_pair(row: r32, j: i32) -> r32:
    (row >> (j - 1)) & 3r32

func get_pixel_to_the_left(row: r32, j: i32) -> r32:
    (row >> j) & 1r32

func get_pixel_to_the_right(row: r32, j: i32) -> r32:
    (row >> (j - 1)) & 1r32

func get_inward_direction(row_above: r32, row_below: r32, j: i32) -> Direction:
    pixel_pair_above = get_pixel_pair(row_above, j)
    pixel_pair_below = get_pixel_pair(row_below, j)
    match pixel_pair_above:
        case 0r32:
            match pixel_pair_below:
                case 1r32 | 3r32:
                    Direction::Left
                case 2r32:
                    Direction::Up
        case 1r32:
            Direction::Down
        case 2r32: 
            match pixel_pair_below:
                case 0r32:
                    Direction::Right
                case 1r32 | 3r32:
                    Direction::Left
                case 2r32:
                    Direction::Up
        case 3r32:
            match pixel_pair_below:
                case 0r32 | 1r32:
                    Direction::Right
                case 2r32:
                    Direction::Up

func get_angle_change(inward: Direction, outward: Direction) -> i32:
    raw_angle_change = (outward.to_i32() - inward.to_i32()).bitmod(2)
    match raw_angle_change:
        case 0r32 | 1r32 | 2r32:
            raw_angle_change
        case 3r32:
            -1

func get_outward_direction(
    row_above: r32,
    row_below: r32,
    j: i32,
    inward_direction: Direction
) -> Direction:
    pixel_pair_above = get_pixel_pair(row_above, j)
    pixel_pair_below = get_pixel_pair(row_below, j)
    match pixel_pair_above:
        case 0r32:
            match pixel_pair_below:
                case 1r32:
                    Direction::Down
                case 2r32 | 3r32:
                    Direction::Left
        case 1r32:
            match pixel_pair_below:
                case 0r32:
                    Direction::Right
                case 1r32:
                    Direction::Down
                case 2r32:
                    match inward_direction:
                        case Direction::Down:
                            Direction::Left
                        case Direction::Up:
                            Direction::Right
                case 3r32:
                    Direction::Left
        case 2r32:
            match pixel_pair_below:
                case 0r32 | 2r32 | 3r32:
                    Direction::Up
                case 1r32:
                    match inward_direction:
                        case Direction::Left:
                            Direction::Up
                        case Direction::Right:
                            Direction::Down
        case 3r32:
            match pixel_pair_below:
                case 0r32 | 2r32:
                    Direction::Right
                case 1r32:
                    Direction::Down


struct StreakCache:
    prev1: i32
    prev2: i32

func get_concave_middle_point(contour: RawContour) -> Point2d:
    N = contour.ilen()
    p0 = contour[N-2]
    p2 = contour[N-1]
    Point2d(
        (p0.x + p2.x) / 2.0, 
        (p0.y + p2.y) / 2.0,\
        
    )

proc find_raw_contours(cc: BinaryImage28) -> []RawContour:
    let mut result = []RawContour()
    let mut boundary_unsearched = BinaryGrid28()
    for 1 <= i <= 29:
        let r_ur = cc[i-1]
        let r_dr = cc[i]
        let r_ul = r_ur << 1
        let r_dl = r_dr << 1
        boundary_unsearched[i] = (r_ur|r_dr|r_ul|r_dl) & (~(r_ur&r_dr&r_ul&r_dl))
    for 1 <= k <= 29:
        while boundary_unsearched[k]:
            let mut contour = RawContour()
            let mut i = k
            let mut j = boundary_unsearched[k].ctz()
            // prepare rows
            let mut row_above = cc[i-1]
            let mut row_below = cc[i]
            // prepare pixel_pairs and initial inward direction
            let mut inward_direction = get_inward_direction(row_above, row_below, j)
            // store initial position and direction
            let i0 = i
            let j0 = j
            let dir0 = inward_direction
            let mut prev_angle_change1 = 0
            let mut prev_angle_change2 = 0
            let mut total_angle_change = 0
            // prepare streaks (raw line segment lengths)
            // -1 means invalid
            let mut prev_streak1 = -1
            let mut prev_streak2 = -1
            let mut current_streak = -1
            // loop in the geometric sense!
            do while !(i == i0 and j == j0 and inward_direction == dir0):
                let outward_direction = get_outward_direction(row_above, row_below, j, inward_direction)
                let angle_change = get_angle_change(inward_direction, outward_direction)
                // update boundary_unsearched
                boundary_unsearched[i] = boundary_unsearched[i] & (~(1r32 << j))
                if angle_change:
                    // update contour and previous streaks
                    if prev_angle_change1 == -1 and prev_angle_change2 == -1 and current_streak == 1 and prev_streak1 != -1 and prev_streak2 == 1:
                        contour.lastx() = get_concave_middle_point(contour)
                        contour.push(Point2dFromIJ28(i, j))
                        prev_streak2 = -1
                        prev_streak1 = -1
                    elif prev_angle_change1 == -1 and prev_streak1 > 0 and prev_streak1 == 1:
                        contour.lastx() = Point2dFromIJ28(i, j)
                        prev_streak2 = prev_streak1
                        prev_streak1 = current_streak
                    elif prev_angle_change1 == -1 and prev_streak1 > 0 and current_streak == 1 and prev_streak1 > 1:
                        contour.lastx() = Point2dFromIJ28(i, j)
                        prev_streak2 = -1
                        prev_streak1 = -1
                    else:
                        contour.push(Point2dFromIJ28(i, j))
                        prev_streak2 = prev_streak1
                        prev_streak1 = current_streak
                    // reset current streak
                    current_streak = 0
                    // update previous angle change
                    prev_angle_change2 = prev_angle_change1
                    prev_angle_change1 = angle_change
                // move
                // update i, j, row below and above
                match outward_direction:
                    case Direction::Up:
                        i = i - 1 
                        row_below = row_above
                        row_above = cc[i-1]
                    case Direction::Down:
                        i = i + 1 
                        row_above = row_below
                        row_below = cc[i]
                    case Direction::Left:
                        j = j + 1
                    case Direction::Right:
                        j = j - 1
                // update inward_direction
                inward_direction = outward_direction
                // update streak
                if current_streak != -1:
                    current_streak++
            if prev_angle_change1 == -1 and current_streak == 1 and prev_streak1 > 0:
                contour.pop_back()
            result.push(contour)
    return result